Project Path: dahao_0

Source Tree:

```txt
dahao_0
‚îú‚îÄ‚îÄ CONTRIBUTING.md
‚îú‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ dahao-template
‚îÇ   ‚îî‚îÄ‚îÄ README.md
‚îú‚îÄ‚îÄ package.json
‚îú‚îÄ‚îÄ src
‚îÇ   ‚îú‚îÄ‚îÄ app
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ api
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ github
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ documents
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [...path]
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ git
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [...path]
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ route.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ governance
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ proposals
‚îÇ   ‚îÇ   ‚îÇ           ‚îú‚îÄ‚îÄ [id]
‚îÇ   ‚îÇ   ‚îÇ           ‚îÇ   ‚îî‚îÄ‚îÄ route.ts
‚îÇ   ‚îÇ   ‚îÇ           ‚îî‚îÄ‚îÄ route.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constitution
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ [sectionId]
‚îÇ   ‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ globals.css
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ page.tsx
‚îÇ   ‚îú‚îÄ‚îÄ components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ LoginButton.tsx
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ constitution
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DiffViewer.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DocumentEditor.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DocumentViewer.tsx
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SectionBrowser.tsx
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ layout
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ Header.tsx
‚îÇ   ‚îú‚îÄ‚îÄ config
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ env.ts
‚îÇ   ‚îú‚îÄ‚îÄ hooks
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useDocument.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ useGitRepo.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ useYAMLData.ts
‚îÇ   ‚îú‚îÄ‚îÄ lib
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ auth
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ github.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ git
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ GitOperationsManager.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ examples.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ operations.ts
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ providers
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ github.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ types.ts
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validation
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ SchemaValidator.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ yaml
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ YamlProcessor.ts
‚îÇ   ‚îú‚îÄ‚îÄ store
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ slices
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ auth.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ document.ts
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ git.ts
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ governance.ts
‚îÇ   ‚îî‚îÄ‚îÄ types
‚îÇ       ‚îî‚îÄ‚îÄ index.ts
‚îú‚îÄ‚îÄ tailwind.config.ts
‚îú‚îÄ‚îÄ tsconfig.json
‚îú‚îÄ‚îÄ whatweardoing.md
‚îî‚îÄ‚îÄ whatwedone.md

```

`dahao_0/CONTRIBUTING.md`:

```md
# Contributing to DAHAO

Thank you for your interest in contributing to DAHAO! This document provides guidelines and instructions for contributing to the project.

## üìã Table of Contents

- [Code of Conduct](#code-of-conduct)
- [Getting Started](#getting-started)
- [Development Workflow](#development-workflow)
- [Code Style Guidelines](#code-style-guidelines)
- [Git Commit Conventions](#git-commit-conventions)
- [Pull Request Process](#pull-request-process)
- [Testing Guidelines](#testing-guidelines)
- [Documentation](#documentation)
- [Community](#community)

## üìú Code of Conduct

By participating in this project, you agree to abide by our Code of Conduct:

- **Be Respectful**: Treat everyone with respect and consideration
- **Be Inclusive**: Welcome people of all backgrounds and identities
- **Be Collaborative**: Work together to resolve conflicts and improve the project
- **Be Professional**: Maintain professionalism in all interactions

## üöÄ Getting Started

1. **Fork the Repository**
   ```bash
   # Via GitHub UI: Click the "Fork" button
   # Or use GitHub CLI:
   gh repo fork dahao-org/dahao_0
   ```

2. **Clone Your Fork**
   ```bash
   git clone https://github.com/YOUR_USERNAME/dahao_0.git
   cd dahao_0
   ```

3. **Add Upstream Remote**
   ```bash
   git remote add upstream https://github.com/dahao-org/dahao_0.git
   ```

4. **Set Up Development Environment**
   ```bash
   ./scripts/setup.sh
   ```

## üíª Development Workflow

### 1. Create a Feature Branch

```bash
# Update main branch
git checkout main
git pull upstream main

# Create feature branch
git checkout -b feature/your-feature-name
# Or for bugs:
git checkout -b fix/bug-description
```

### 2. Make Your Changes

- Write clean, documented code
- Follow the code style guidelines
- Add tests for new functionality
- Update documentation as needed

### 3. Test Your Changes

```bash
# Run all tests
npm test

# Run specific test suite
npm test -- --testPathPattern=git

# Run linting
npm run lint

# Type checking
npm run type-check
```

### 4. Commit Your Changes

```bash
# Stage changes
git add .

# Commit with conventional message
git commit -m "feat: add new feature description"
```

### 5. Push to Your Fork

```bash
git push origin feature/your-feature-name
```

### 6. Create Pull Request

- Go to GitHub and create a PR from your fork
- Fill out the PR template completely
- Link any related issues

## üìù Code Style Guidelines

### TypeScript/JavaScript

```typescript
// ‚úÖ Good: Clear, typed, documented
/**
 * Validates a DAHAO constitution section
 * @param section - The section to validate
 * @returns Validation result with any errors
 */
export function validateSection(section: ConstitutionSection): ValidationResult {
  // Implementation
}

// ‚ùå Bad: No types, no docs
export function validate(s) {
  // Implementation
}
```

### React Components

```tsx
// ‚úÖ Good: Typed props, clear structure
interface DocumentViewerProps {
  document: Document;
  onEdit?: (id: string) => void;
  className?: string;
}

export const DocumentViewer: React.FC<DocumentViewerProps> = ({
  document,
  onEdit,
  className
}) => {
  // Component logic
  return (
    <div className={cn("document-viewer", className)}>
      {/* Component JSX */}
    </div>
  );
};

// ‚ùå Bad: No types, unclear props
export const DocViewer = (props) => {
  return <div>{/* ... */}</div>;
};
```

### File Organization

```
src/
‚îú‚îÄ‚îÄ components/          # React components
‚îÇ   ‚îî‚îÄ‚îÄ ComponentName/   # Component folder
‚îÇ       ‚îú‚îÄ‚îÄ index.tsx    # Component export
‚îÇ       ‚îú‚îÄ‚îÄ ComponentName.tsx
‚îÇ       ‚îú‚îÄ‚îÄ ComponentName.test.tsx
‚îÇ       ‚îî‚îÄ‚îÄ ComponentName.module.css
‚îú‚îÄ‚îÄ lib/                 # Core libraries
‚îÇ   ‚îî‚îÄ‚îÄ feature/         # Feature folder
‚îÇ       ‚îú‚îÄ‚îÄ index.ts     # Public API
‚îÇ       ‚îú‚îÄ‚îÄ implementation.ts
‚îÇ       ‚îî‚îÄ‚îÄ types.ts
‚îî‚îÄ‚îÄ hooks/              # Custom React hooks
```

### Naming Conventions

- **Components**: PascalCase (e.g., `DocumentEditor`)
- **Functions**: camelCase (e.g., `validateDocument`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `MAX_FILE_SIZE`)
- **Files**: kebab-case (e.g., `git-operations.ts`)
- **Types/Interfaces**: PascalCase (e.g., `GitOperation`)

## üìã Git Commit Conventions

We follow the [Conventional Commits](https://www.conventionalcommits.org/) specification:

### Format

```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types

- **feat**: New feature
- **fix**: Bug fix
- **docs**: Documentation changes
- **style**: Code style changes (formatting, etc.)
- **refactor**: Code refactoring
- **perf**: Performance improvements
- **test**: Adding or updating tests
- **chore**: Maintenance tasks
- **ci**: CI/CD changes

### Examples

```bash
# Feature
feat(git): add support for GitLab provider

# Bug fix
fix(auth): resolve GitHub OAuth callback issue

# Documentation
docs(readme): update installation instructions

# Refactoring
refactor(components): simplify DocumentEditor logic

# With scope and body
feat(governance): implement voting system

Adds the ability for members to vote on proposals through
the UI. Votes are recorded as Git commits with special
metadata.

Closes #123
```

## üîÑ Pull Request Process

### Before Submitting

1. **Update from upstream**
   ```bash
   git fetch upstream
   git rebase upstream/main
   ```

2. **Run all checks**
   ```bash
   npm run lint
   npm run type-check
   npm test
   ```

3. **Update documentation**
   - Add/update relevant documentation
   - Update README if needed
   - Add JSDoc comments to new functions

### PR Template

```markdown
## Description
Brief description of changes

## Type of Change
- [ ] Bug fix
- [ ] New feature
- [ ] Breaking change
- [ ] Documentation update

## Testing
- [ ] Unit tests pass
- [ ] Integration tests pass
- [ ] Manual testing completed

## Checklist
- [ ] Code follows style guidelines
- [ ] Self-review completed
- [ ] Documentation updated
- [ ] Tests added/updated
- [ ] No breaking changes (or documented)

## Related Issues
Closes #(issue number)

## Screenshots (if applicable)
```

### Review Process

1. **Automated Checks**: CI/CD runs tests and linting
2. **Code Review**: At least one maintainer reviews
3. **Discussion**: Address feedback and questions
4. **Approval**: Maintainer approves
5. **Merge**: PR is merged (usually squash-merged)

## üß™ Testing Guidelines

### Unit Tests

```typescript
// Example test file
describe('GitOperationsManager', () => {
  describe('createBranch', () => {
    it('should create a new branch from main', async () => {
      const manager = new GitOperationsManager();
      const branch = await manager.createBranch('feature/test', 'main');
      
      expect(branch.name).toBe('feature/test');
      expect(branch.baseBranch).toBe('main');
    });

    it('should throw error for invalid branch name', async () => {
      const manager = new GitOperationsManager();
      
      await expect(
        manager.createBranch('invalid name', 'main')
      ).rejects.toThrow('Invalid branch name');
    });
  });
});
```

### Integration Tests

```typescript
// Test real Git operations
describe('Git Integration', () => {
  it('should create and merge a pull request', async () => {
    // Test the full flow
  });
});
```

### E2E Tests

```typescript
// Test user workflows
describe('Document Editing', () => {
  it('should allow user to edit and submit changes', async () => {
    // Test UI interactions
  });
});
```

## üìö Documentation

### Code Documentation

- Add JSDoc comments to all exported functions
- Include parameter descriptions and return types
- Add examples for complex functions

```typescript
/**
 * Merges a pull request using the specified strategy
 * 
 * @param repo - Repository name
 * @param prNumber - Pull request number
 * @param strategy - Merge strategy ('merge', 'squash', or 'rebase')
 * @returns The resulting merge commit
 * 
 * @example
 * const merge = await mergePR('dahao-core', 123, 'squash');
 * console.log(`Merged as ${merge.sha}`);
 */
export async function mergePR(
  repo: string,
  prNumber: number,
  strategy: MergeStrategy
): Promise<MergeResult> {
  // Implementation
}
```

### README Updates

Update the README when:
- Adding new features
- Changing setup procedures
- Modifying configuration options
- Adding new dependencies

### Architecture Documentation

Update architecture docs when:
- Adding new components
- Changing data flow
- Modifying core algorithms
- Updating dependencies

## üë• Community

### Getting Help

- **Discord**: Join our [Discord server](https://discord.gg/dahao)
- **GitHub Issues**: Search existing issues or create new ones
- **Documentation**: Check our [docs](https://docs.dahao.org)

### Communication Channels

- **GitHub Discussions**: General discussions and ideas
- **GitHub Issues**: Bug reports and feature requests
- **Discord**: Real-time chat and support
- **Forum**: Long-form discussions

### Recognition

Contributors are recognized in:
- The repository's Contributors page
- Release notes
- Project documentation
- Community highlights

## üéØ What We're Looking For

### High Priority

- Git provider integrations (GitLab, Gitea)
- Performance optimizations
- Accessibility improvements
- Security enhancements
- Documentation improvements

### Good First Issues

Look for issues labeled `good first issue` for:
- Documentation fixes
- Simple bug fixes
- Small feature additions
- Test improvements

### Feature Requests

Before implementing new features:
1. Check existing issues/discussions
2. Open an issue to discuss the feature
3. Get feedback from maintainers
4. Implement after approval

## üôè Thank You!

Your contributions make DAHAO better for everyone. We appreciate your time and effort in improving this project!

---

**Questions?** Feel free to ask in Discord or open a GitHub Discussion.
```

`dahao_0/README.md`:

```md
# DAHAO - Decentralized Autonomous Hybrid-AI Organization

A revolutionary Git-based organizational governance system that enables democratic decision-making through version control.

## üéØ Project Overview

DAHAO (ÈÅì) represents "The Way" - a completely decentralized organizational framework where:

- **Everything is Git**: No traditional databases, just Git repositories
- **YAML as Data**: Human-readable, diff-friendly data format
- **Forks as Sub-Organizations**: Natural inheritance and customization
- **Pull Requests as Proposals**: Democratic governance through Git workflows
- **Complete Audit Trail**: Every change tracked through Git history

## üèóÔ∏è Architecture

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      User Interface Layer                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ  Web UI  ‚îÇ  ‚îÇ   CLI    ‚îÇ  ‚îÇ   API    ‚îÇ  ‚îÇ  Mobile  ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                    Git Operations Manager                        ‚îÇ
‚îÇ  - Branch Management      - Commit Operations                   ‚îÇ
‚îÇ  - PR Creation           - Conflict Resolution                  ‚îÇ
‚îÇ  - Inheritance Logic     - Webhook Processing                   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                 ‚îÇ
                                 ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                        Git Providers                             ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ
‚îÇ  ‚îÇ  GitHub  ‚îÇ  ‚îÇ  GitLab  ‚îÇ  ‚îÇ  Gitea   ‚îÇ  ‚îÇ  Local   ‚îÇ      ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üöÄ Getting Started

### Prerequisites

- Node.js 18.0+ (LTS recommended)
- Git 2.30+
- GitHub account (for GitHub provider)
- npm or yarn package manager

### Quick Start

1. **Clone the repository**
   ```bash
   git clone https://github.com/your-org/dahao_0.git
   cd dahao_0
   ```

2. **Run the setup script**
   ```bash
   chmod +x scripts/setup.sh
   ./scripts/setup.sh
   ```

3. **Configure environment**
   ```bash
   # Edit .env file with your settings
   nano .env
   ```

4. **Start development server**
   ```bash
   npm run dev
   # or
   yarn dev
   ```

5. **Open browser**
   ```
   http://localhost:3000
   ```

## üíª Development Setup

### Manual Setup

1. **Install dependencies**
   ```bash
   npm install
   # or
   yarn install
   ```

2. **Environment Configuration**
   ```bash
   cp .env.example .env
   ```

3. **Configure GitHub OAuth App**
   - Go to GitHub Settings > Developer Settings > OAuth Apps
   - Create a new OAuth App
   - Set Authorization callback URL: `http://localhost:3000/api/auth/github/callback`
   - Copy Client ID and Client Secret to `.env`

4. **Initialize DAHAO Template**
   ```bash
   npm run init:template
   ```

### Project Structure

```
dahao_0/
‚îú‚îÄ‚îÄ src/                    # Source code
‚îÇ   ‚îú‚îÄ‚îÄ app/               # Next.js App Router
‚îÇ   ‚îú‚îÄ‚îÄ components/        # React components
‚îÇ   ‚îú‚îÄ‚îÄ lib/              # Core libraries
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ git/          # Git operations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ yaml/         # YAML processing
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ validation/   # Schema validation
‚îÇ   ‚îú‚îÄ‚îÄ hooks/            # React hooks
‚îÇ   ‚îî‚îÄ‚îÄ types/            # TypeScript types
‚îú‚îÄ‚îÄ dahao-template/        # DAHAO template structure
‚îÇ   ‚îú‚îÄ‚îÄ constitution/     # Constitutional documents
‚îÇ   ‚îú‚îÄ‚îÄ governance/       # Governance rules
‚îÇ   ‚îú‚îÄ‚îÄ terms/           # Term definitions
‚îÇ   ‚îî‚îÄ‚îÄ tokens/          # Token economics
‚îú‚îÄ‚îÄ scripts/              # Utility scripts
‚îî‚îÄ‚îÄ docs/                # Documentation
```

## üîß Environment Variables

Create a `.env` file in the root directory:

```env
# GitHub OAuth (Required for GitHub provider)
GITHUB_CLIENT_ID=your_github_client_id
GITHUB_CLIENT_SECRET=your_github_client_secret

# Session Secret (Required)
SESSION_SECRET=your_secure_session_secret_min_32_chars

# App Configuration
NEXT_PUBLIC_APP_URL=http://localhost:3000
NEXT_PUBLIC_GIT_PROVIDER=github

# Optional: Custom Git Server
GIT_SERVER_URL=https://git.example.com
GIT_SERVER_TOKEN=your_git_server_token

# Optional: Feature Flags
ENABLE_AI_AGENTS=false
ENABLE_TOKEN_ECONOMICS=false
```

## üèÉ Running Locally

### Development Mode

```bash
# Start development server with hot reload
npm run dev

# Run in specific port
PORT=4000 npm run dev
```

### Production Mode

```bash
# Build for production
npm run build

# Start production server
npm start
```

### Testing

```bash
# Run all tests
npm test

# Run tests in watch mode
npm test:watch

# Run E2E tests
npm run test:e2e
```

### Validation

```bash
# Validate all YAML files
npm run validate

# Check TypeScript
npm run type-check

# Lint code
npm run lint
```

## üöÄ Deployment

### Vercel (Recommended)

1. **Install Vercel CLI**
   ```bash
   npm i -g vercel
   ```

2. **Deploy**
   ```bash
   vercel
   ```

3. **Set environment variables in Vercel dashboard**

### Docker

1. **Build image**
   ```bash
   docker build -t dahao .
   ```

2. **Run container**
   ```bash
   docker run -p 3000:3000 --env-file .env dahao
   ```

### Self-Hosted

See [docs/DEPLOYMENT.md](docs/DEPLOYMENT.md) for detailed self-hosting instructions.

## ü§ù Contributing

We welcome contributions! Please see our [Contributing Guidelines](CONTRIBUTING.md) for details.

### Quick Contribution Guide

1. Fork the repository
2. Create a feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## üìö Documentation

- [Architecture Overview](docs/ARCHITECTURE.md) - Detailed technical architecture
- [API Reference](docs/API.md) - REST API documentation
- [Git Operations](docs/GIT_OPERATIONS.md) - Git integration details
- [YAML Schemas](docs/SCHEMAS.md) - Data structure documentation

## üõ°Ô∏è Security

- All data is stored in Git repositories
- Authentication via GitHub OAuth
- Authorization through Git permissions
- Complete audit trail via Git history

For security issues, please email security@dahao.org

## üìÑ License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## üôè Acknowledgments

- Inspired by decentralized governance principles
- Built on the shoulders of Git
- Powered by the open-source community

## üîó Links

- [Website](https://dahao.org)
- [Documentation](https://docs.dahao.org)
- [Community Forum](https://forum.dahao.org)
- [Discord](https://discord.gg/dahao)

---

<p align="center">
  Made with ‚ù§Ô∏è by the DAHAO Community
</p>
```

`dahao_0/dahao-template/README.md`:

```md
# DAHAO Template Repository

This is the official template for DAHAO (Decentralized Autonomous Holographic Adaptive Organizations) - a YAML-based framework for DAO governance documentation.

## üèóÔ∏è Repository Structure

```
dahao-template/
‚îú‚îÄ‚îÄ .github/workflows/     # CI/CD workflows for validation
‚îú‚îÄ‚îÄ constitution/          # Foundational governance documents
‚îÇ   ‚îú‚îÄ‚îÄ manifest.yaml     # Main constitution index
‚îÇ   ‚îî‚îÄ‚îÄ sections/         # Individual constitution sections
‚îú‚îÄ‚îÄ terms/                # Terminology and definitions
‚îÇ   ‚îú‚îÄ‚îÄ definitions/      # Term definition files
‚îÇ   ‚îî‚îÄ‚îÄ registry/         # Central term registry
‚îú‚îÄ‚îÄ governance/           # Governance rules and structures
‚îÇ   ‚îú‚îÄ‚îÄ rules/           # Voting and decision rules
‚îÇ   ‚îú‚îÄ‚îÄ roles/           # Role definitions
‚îÇ   ‚îî‚îÄ‚îÄ members/         # Member profiles
‚îú‚îÄ‚îÄ tokens/              # Token economics configuration
‚îÇ   ‚îî‚îÄ‚îÄ economics.yaml   # Tokenomics specification
‚îú‚îÄ‚îÄ proposals/           # Governance proposals (DIPs)
‚îî‚îÄ‚îÄ .dahao/             # DAHAO configuration
    ‚îú‚îÄ‚îÄ config.yaml     # Repository configuration
    ‚îî‚îÄ‚îÄ version         # DAHAO version

```

## üöÄ Getting Started

### 1. Fork this Template

Click "Use this template" on GitHub to create your own DAHAO repository.

### 2. Configure Your DAO

Edit `.dahao/config.yaml` with your organization's details:

```yaml
organization:
  name: Your DAO Name
  chain: ethereum  # or polygon, arbitrum, etc.
  multisig: "0xYourMultisigAddress"
```

### 3. Customize Constitution

Modify `constitution/manifest.yaml` and add sections in `constitution/sections/`.

### 4. Define Terms

Add your DAO-specific terms in `terms/definitions/`.

### 5. Set Governance Rules

Configure voting rules, roles, and parameters in `governance/`.

### 6. Configure Tokenomics

Update `tokens/economics.yaml` with your token distribution and incentives.

## üìù File Formats

### Constitution Section
```yaml
id: section-id
version: 1.0.0
title: Section Title
content: |
  Your constitution content here...
metadata:
  created: 2025-01-22T00:00:00Z
  authors: [author-id]
```

### Term Definition
```yaml
term: Your Term
definition: Clear definition of the term
category: governance
aliases: [alt-name]
related_terms: [other-term]
```

### Governance Rule
```yaml
id: rule-id
type: voting
title: Rule Title
rules:
  - description: What the rule does
    conditions: [when it applies]
    actions: [what happens]
parameters:
  quorum: 0.10
  threshold: 0.51
```

### Proposal
```yaml
id: DIP-XXX
title: Proposal Title
type: governance
author: member-id
description: What the proposal does
status: draft
```

## üîç Validation

The repository includes GitHub Actions workflows that:
- Validate YAML syntax
- Check schema compliance
- Ensure required files exist
- Verify cross-references

Run validation locally:
```bash
# Install dependencies
pip install pyyaml jsonschema

# Validate structure
python scripts/validate.py
```

## üìö Schema Documentation

Detailed schemas are available in `src/schemas/`:
- `document-schema.yaml` - Constitution documents
- `term-schema.yaml` - Term definitions
- `governance-schema.yaml` - Governance rules
- `member-schema.yaml` - Member profiles
- `proposal-schema.yaml` - Proposals

## ü§ù Contributing

1. Create proposals in `proposals/` directory
2. Submit PR with your changes
3. Automated validation will run
4. Community review and voting
5. Merge after approval

## üì¶ Integration

DAHAO integrates with:
- **IPFS**: Decentralized storage
- **Snapshot**: Off-chain voting
- **Discord**: Community notifications
- **Smart Contracts**: On-chain execution

## üîó Resources

- [DAHAO Documentation](https://dahao.org/docs)
- [Schema Reference](https://dahao.org/schemas)
- [Example DAOs](https://dahao.org/examples)
- [Community Forum](https://forum.dahao.org)

## üìÑ License

This template is released under the MIT License. Your DAO's content may have its own license.
```

`dahao_0/package.json`:

```json
{
  "name": "dahao",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "next": "14.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "js-yaml": "^4.1.0",
    "ajv": "^8.12.0",
    "simple-git": "^3.22.0",
    "lucide-react": "^0.321.0",
    "@radix-ui/react-dialog": "^1.0.5",
    "@radix-ui/react-dropdown-menu": "^2.0.6",
    "@radix-ui/react-slot": "^1.0.2",
    "class-variance-authority": "^0.7.0",
    "clsx": "^2.1.0",
    "tailwind-merge": "^2.2.1",
    "tailwindcss-animate": "^1.0.7",
    "@octokit/rest": "^20.0.2",
    "@monaco-editor/react": "^4.6.0",
    "react-markdown": "^9.0.1",
    "diff": "^5.1.0",
    "@heroicons/react": "^2.1.1"
  },
  "devDependencies": {
    "@types/node": "^20.11.17",
    "@types/react": "^18.2.55",
    "@types/react-dom": "^18.2.19",
    "@types/js-yaml": "^4.0.9",
    "@types/diff": "^5.0.9",
    "typescript": "^5.3.3",
    "tailwindcss": "^3.4.1",
    "postcss": "^8.4.35",
    "autoprefixer": "^10.4.17",
    "eslint": "^8.56.0",
    "eslint-config-next": "14.1.0"
  }
}
```

`dahao_0/src/app/api/auth/github/route.ts`:

```ts
import { NextRequest, NextResponse } from 'next/server';
import { getGitHubAuthUrl, exchangeCodeForToken, getGitHubUser } from '@/lib/auth/github';

// GitHub OAuth callback handler
export async function GET(request: NextRequest) {
  const searchParams = request.nextUrl.searchParams;
  const code = searchParams.get('code');
  const state = searchParams.get('state');

  // Initial OAuth redirect
  if (!code) {
    const authUrl = getGitHubAuthUrl();
    return NextResponse.redirect(authUrl);
  }

  // Handle OAuth callback
  try {
    // Verify state parameter for CSRF protection
    const sessionState = request.cookies.get('oauth_state')?.value;
    if (state !== sessionState) {
      return NextResponse.json(
        { error: 'Invalid state parameter' },
        { status: 400 }
      );
    }

    // Exchange code for access token
    const tokenData = await exchangeCodeForToken(code);
    
    if (!tokenData.access_token) {
      throw new Error('No access token received');
    }

    // Get user information from GitHub
    const user = await getGitHubUser(tokenData.access_token);

    // Create user session
    const response = NextResponse.redirect(new URL('/', request.url));
    
    // Set secure HTTP-only cookie with user session
    response.cookies.set('session', JSON.stringify({
      user: {
        id: user.id.toString(),
        username: user.login,
        email: user.email,
        avatarUrl: user.avatar_url,
        githubId: user.id.toString(),
      },
      accessToken: tokenData.access_token,
    }), {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      sameSite: 'lax',
      maxAge: 60 * 60 * 24 * 7, // 7 days
    });

    // Clear OAuth state cookie
    response.cookies.delete('oauth_state');

    return response;
  } catch (error) {
    console.error('GitHub OAuth error:', error);
    return NextResponse.json(
      { error: 'Authentication failed' },
      { status: 500 }
    );
  }
}
```

`dahao_0/src/app/api/documents/[...path]/route.ts`:

```ts
import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { getSession } from '@/lib/auth/session';
import matter from 'gray-matter';

const REPO_OWNER = process.env.GITHUB_REPO_OWNER || 'dahao-dao';
const REPO_NAME = process.env.GITHUB_REPO_NAME || 'dahao';
const DOCUMENTS_PATH = 'documents';

async function getOctokit(request: NextRequest) {
  const session = await getSession(request);
  if (!session?.accessToken) {
    throw new Error('Unauthorized');
  }
  return new Octokit({ auth: session.accessToken });
}

// GET /api/documents - List all documents
// GET /api/documents/[id] - Get specific document
// GET /api/documents/search - Search documents
export async function GET(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const pathSegments = params.path || [];
    
    if (pathSegments[0] === 'search') {
      // Search documents
      const searchParams = request.nextUrl.searchParams;
      const query = searchParams.get('q') || '';
      
      const { data } = await octokit.search.code({
        q: `${query} repo:${REPO_OWNER}/${REPO_NAME} path:${DOCUMENTS_PATH}`,
      });

      const documents = await Promise.all(
        data.items.map(async (item) => {
          const fileData = await octokit.repos.getContent({
            owner: REPO_OWNER,
            repo: REPO_NAME,
            path: item.path,
          });

          if ('content' in fileData.data) {
            const content = Buffer.from(fileData.data.content, 'base64').toString('utf-8');
            const { data: frontmatter, content: body } = matter(content);
            
            return {
              id: item.path.replace(`${DOCUMENTS_PATH}/`, '').replace('.md', ''),
              title: frontmatter.title || 'Untitled',
              content: body,
              path: item.path,
              lastModified: frontmatter.lastModified || new Date().toISOString(),
              author: frontmatter.author || 'Unknown',
              tags: frontmatter.tags || [],
              type: frontmatter.type || 'standard',
            };
          }
        })
      );

      return NextResponse.json(documents.filter(Boolean));
    } else if (pathSegments.length > 0) {
      // Get specific document
      const documentId = pathSegments.join('/');
      const filePath = `${DOCUMENTS_PATH}/${documentId}.md`;
      
      const { data } = await octokit.repos.getContent({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        path: filePath,
      });

      if ('content' in data) {
        const content = Buffer.from(data.content, 'base64').toString('utf-8');
        const { data: frontmatter, content: body } = matter(content);
        
        return NextResponse.json({
          id: documentId,
          title: frontmatter.title || 'Untitled',
          content: body,
          path: filePath,
          lastModified: frontmatter.lastModified || new Date().toISOString(),
          author: frontmatter.author || 'Unknown',
          tags: frontmatter.tags || [],
          type: frontmatter.type || 'standard',
        });
      }
    } else {
      // List all documents
      const searchParams = request.nextUrl.searchParams;
      const type = searchParams.get('type');
      
      const { data } = await octokit.repos.getContent({
        owner: REPO_OWNER,
        repo: REPO_NAME,
        path: DOCUMENTS_PATH,
      });

      if (Array.isArray(data)) {
        const documents = await Promise.all(
          data
            .filter(file => file.type === 'file' && file.name.endsWith('.md'))
            .map(async (file) => {
              const fileData = await octokit.repos.getContent({
                owner: REPO_OWNER,
                repo: REPO_NAME,
                path: file.path,
              });

              if ('content' in fileData.data) {
                const content = Buffer.from(fileData.data.content, 'base64').toString('utf-8');
                const { data: frontmatter } = matter(content);
                
                if (type && frontmatter.type !== type) {
                  return null;
                }
                
                return {
                  id: file.path.replace(`${DOCUMENTS_PATH}/`, '').replace('.md', ''),
                  title: frontmatter.title || 'Untitled',
                  path: file.path,
                  lastModified: frontmatter.lastModified || new Date().toISOString(),
                  author: frontmatter.author || 'Unknown',
                  tags: frontmatter.tags || [],
                  type: frontmatter.type || 'standard',
                };
              }
            })
        );

        return NextResponse.json(documents.filter(Boolean));
      }
    }

    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  } catch (error) {
    console.error('Documents API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST /api/documents - Create new document
export async function POST(request: NextRequest) {
  try {
    const octokit = await getOctokit(request);
    const session = await getSession(request);
    const body = await request.json();
    
    const { title, content, path, tags = [], type = 'standard' } = body;
    const documentPath = path || `${title.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;
    const filePath = `${DOCUMENTS_PATH}/${documentPath}.md`;

    const frontmatter = {
      title,
      author: session?.user?.username || 'Unknown',
      lastModified: new Date().toISOString(),
      tags,
      type,
    };

    const fileContent = matter.stringify(content, frontmatter);

    const { data } = await octokit.repos.createOrUpdateFileContents({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: filePath,
      message: `Create document: ${title}`,
      content: Buffer.from(fileContent).toString('base64'),
    });

    return NextResponse.json({
      id: documentPath,
      path: filePath,
      sha: data.content?.sha,
    });
  } catch (error) {
    console.error('Documents API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// PUT /api/documents/[id] - Update document
export async function PUT(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const documentId = params.path.join('/');
    const filePath = `${DOCUMENTS_PATH}/${documentId}.md`;
    const body = await request.json();

    // Get current file
    const { data: currentFile } = await octokit.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: filePath,
    });

    if (!('sha' in currentFile)) {
      return NextResponse.json(
        { error: 'Document not found' },
        { status: 404 }
      );
    }

    // Parse existing content
    const existingContent = Buffer.from(currentFile.content, 'base64').toString('utf-8');
    const { data: existingFrontmatter } = matter(existingContent);

    // Update frontmatter
    const updatedFrontmatter = {
      ...existingFrontmatter,
      ...body,
      lastModified: new Date().toISOString(),
    };

    const fileContent = matter.stringify(body.content || '', updatedFrontmatter);

    // Update file
    const { data } = await octokit.repos.createOrUpdateFileContents({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: filePath,
      message: `Update document: ${updatedFrontmatter.title}`,
      content: Buffer.from(fileContent).toString('base64'),
      sha: currentFile.sha,
    });

    return NextResponse.json({
      id: documentId,
      path: filePath,
      sha: data.content?.sha,
    });
  } catch (error) {
    console.error('Documents API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// DELETE /api/documents/[id] - Delete document
export async function DELETE(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const documentId = params.path.join('/');
    const filePath = `${DOCUMENTS_PATH}/${documentId}.md`;

    // Get current file
    const { data: currentFile } = await octokit.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: filePath,
    });

    if (!('sha' in currentFile)) {
      return NextResponse.json(
        { error: 'Document not found' },
        { status: 404 }
      );
    }

    // Delete file
    await octokit.repos.deleteFile({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: filePath,
      message: `Delete document: ${documentId}`,
      sha: currentFile.sha,
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Documents API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

`dahao_0/src/app/api/git/[...path]/route.ts`:

```ts
import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { getSession } from '@/lib/auth/session';

const REPO_OWNER = process.env.GITHUB_REPO_OWNER || 'dahao-dao';
const REPO_NAME = process.env.GITHUB_REPO_NAME || 'dahao';

async function getOctokit(request: NextRequest) {
  const session = await getSession(request);
  if (!session?.accessToken) {
    throw new Error('Unauthorized');
  }
  return new Octokit({ auth: session.accessToken });
}

// GET /api/git/files - List files in repository
// GET /api/git/files/[path] - Get file content
// GET /api/git/commits - Get commit history
// GET /api/git/branches - List branches
export async function GET(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const pathSegments = params.path || [];
    const endpoint = pathSegments[0];

    switch (endpoint) {
      case 'files': {
        const filePath = pathSegments.slice(1).join('/');
        
        if (filePath) {
          // Get specific file content
          const { data } = await octokit.repos.getContent({
            owner: REPO_OWNER,
            repo: REPO_NAME,
            path: filePath,
          });

          if ('content' in data) {
            return NextResponse.json({
              path: data.path,
              content: Buffer.from(data.content, 'base64').toString('utf-8'),
              sha: data.sha,
              type: data.type,
            });
          }
        } else {
          // List files in root or specified directory
          const searchParams = request.nextUrl.searchParams;
          const path = searchParams.get('path') || '';
          
          const { data } = await octokit.repos.getContent({
            owner: REPO_OWNER,
            repo: REPO_NAME,
            path,
          });

          if (Array.isArray(data)) {
            return NextResponse.json(data.map(file => ({
              path: file.path,
              type: file.type,
              sha: file.sha,
            })));
          }
        }
        break;
      }

      case 'commits': {
        const { data } = await octokit.repos.listCommits({
          owner: REPO_OWNER,
          repo: REPO_NAME,
          per_page: 50,
        });

        return NextResponse.json(data.map(commit => ({
          sha: commit.sha,
          author: commit.commit.author?.name || 'Unknown',
          message: commit.commit.message,
          date: commit.commit.author?.date || new Date().toISOString(),
        })));
      }

      case 'branches': {
        const { data } = await octokit.repos.listBranches({
          owner: REPO_OWNER,
          repo: REPO_NAME,
        });

        return NextResponse.json(data.map(branch => ({
          name: branch.name,
          protected: branch.protected,
        })));
      }

      default:
        return NextResponse.json(
          { error: 'Invalid endpoint' },
          { status: 400 }
        );
    }

    return NextResponse.json({ error: 'Not found' }, { status: 404 });
  } catch (error) {
    console.error('Git API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST /api/git/files - Create new file
// POST /api/git/branches - Create new branch
// POST /api/git/pull-requests - Create pull request
export async function POST(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const pathSegments = params.path || [];
    const endpoint = pathSegments[0];
    const body = await request.json();

    switch (endpoint) {
      case 'files': {
        const { path, content, message } = body;
        
        const { data } = await octokit.repos.createOrUpdateFileContents({
          owner: REPO_OWNER,
          repo: REPO_NAME,
          path,
          message,
          content: Buffer.from(content).toString('base64'),
        });

        return NextResponse.json({
          path: data.content?.path,
          sha: data.content?.sha,
        });
      }

      case 'branches': {
        const { branchName } = body;
        
        // Get the SHA of the main branch
        const { data: mainBranch } = await octokit.repos.getBranch({
          owner: REPO_OWNER,
          repo: REPO_NAME,
          branch: 'main',
        });

        // Create new branch
        const { data } = await octokit.git.createRef({
          owner: REPO_OWNER,
          repo: REPO_NAME,
          ref: `refs/heads/${branchName}`,
          sha: mainBranch.commit.sha,
        });

        return NextResponse.json({
          name: branchName,
          sha: data.object.sha,
        });
      }

      case 'pull-requests': {
        const { title, body: description, base = 'main', head } = body;
        
        const { data } = await octokit.pulls.create({
          owner: REPO_OWNER,
          repo: REPO_NAME,
          title,
          body: description,
          base,
          head,
        });

        return NextResponse.json({
          number: data.number,
          url: data.html_url,
        });
      }

      default:
        return NextResponse.json(
          { error: 'Invalid endpoint' },
          { status: 400 }
        );
    }
  } catch (error) {
    console.error('Git API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// PUT /api/git/files - Update existing file
export async function PUT(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const body = await request.json();
    const { path, content, message } = body;

    // Get current file to get its SHA
    const { data: currentFile } = await octokit.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path,
    });

    if (!('sha' in currentFile)) {
      return NextResponse.json(
        { error: 'File not found' },
        { status: 404 }
      );
    }

    // Update file
    const { data } = await octokit.repos.createOrUpdateFileContents({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path,
      message,
      content: Buffer.from(content).toString('base64'),
      sha: currentFile.sha,
    });

    return NextResponse.json({
      path: data.content?.path,
      sha: data.content?.sha,
    });
  } catch (error) {
    console.error('Git API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// DELETE /api/git/files - Delete file
export async function DELETE(
  request: NextRequest,
  { params }: { params: { path: string[] } }
) {
  try {
    const octokit = await getOctokit(request);
    const body = await request.json();
    const { path, message } = body;

    // Get current file to get its SHA
    const { data: currentFile } = await octokit.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path,
    });

    if (!('sha' in currentFile)) {
      return NextResponse.json(
        { error: 'File not found' },
        { status: 404 }
      );
    }

    // Delete file
    await octokit.repos.deleteFile({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path,
      message,
      sha: currentFile.sha,
    });

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Git API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

`dahao_0/src/app/api/governance/proposals/[id]/route.ts`:

```ts
import { NextResponse } from 'next/server';
import { db } from '@/lib/db';
import { proposals, votes, comments } from '@/lib/db/schema';
import { eq, desc } from 'drizzle-orm';
import { validateSession } from '@/lib/auth/session';

export async function GET(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const proposalId = parseInt(params.id);
    if (isNaN(proposalId)) {
      return NextResponse.json(
        { error: 'Invalid proposal ID' },
        { status: 400 }
      );
    }

    // Get proposal with author info
    const proposal = await db
      .select({
        id: proposals.id,
        title: proposals.title,
        description: proposals.description,
        category: proposals.category,
        status: proposals.status,
        votesFor: proposals.votesFor,
        votesAgainst: proposals.votesAgainst,
        votesAbstain: proposals.votesAbstain,
        createdAt: proposals.createdAt,
        updatedAt: proposals.updatedAt,
        authorId: proposals.authorId,
      })
      .from(proposals)
      .where(eq(proposals.id, proposalId))
      .limit(1);

    if (proposal.length === 0) {
      return NextResponse.json(
        { error: 'Proposal not found' },
        { status: 404 }
      );
    }

    // Get votes for this proposal
    const proposalVotes = await db
      .select({
        userId: votes.userId,
        vote: votes.vote,
        createdAt: votes.createdAt,
      })
      .from(votes)
      .where(eq(votes.proposalId, proposalId));

    // Get comments for this proposal
    const proposalComments = await db
      .select({
        id: comments.id,
        content: comments.content,
        authorId: comments.authorId,
        createdAt: comments.createdAt,
      })
      .from(comments)
      .where(eq(comments.proposalId, proposalId))
      .orderBy(desc(comments.createdAt));

    return NextResponse.json({
      proposal: proposal[0],
      votes: proposalVotes,
      comments: proposalComments,
    });
  } catch (error) {
    console.error('Failed to fetch proposal:', error);
    return NextResponse.json(
      { error: 'Failed to fetch proposal' },
      { status: 500 }
    );
  }
}

export async function PUT(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await validateSession(request);
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const proposalId = parseInt(params.id);
    if (isNaN(proposalId)) {
      return NextResponse.json(
        { error: 'Invalid proposal ID' },
        { status: 400 }
      );
    }

    const { title, description, category } = await request.json();

    // Check if user is the author
    const proposal = await db
      .select({ authorId: proposals.authorId })
      .from(proposals)
      .where(eq(proposals.id, proposalId))
      .limit(1);

    if (proposal.length === 0) {
      return NextResponse.json(
        { error: 'Proposal not found' },
        { status: 404 }
      );
    }

    if (proposal[0].authorId !== session.userId) {
      return NextResponse.json(
        { error: 'You can only edit your own proposals' },
        { status: 403 }
      );
    }

    // Update proposal
    const updated = await db
      .update(proposals)
      .set({
        title,
        description,
        category,
        updatedAt: new Date(),
      })
      .where(eq(proposals.id, proposalId))
      .returning();

    return NextResponse.json(updated[0]);
  } catch (error) {
    console.error('Failed to update proposal:', error);
    return NextResponse.json(
      { error: 'Failed to update proposal' },
      { status: 500 }
    );
  }
}

export async function DELETE(
  request: Request,
  { params }: { params: { id: string } }
) {
  try {
    const session = await validateSession(request);
    if (!session) {
      return NextResponse.json(
        { error: 'Unauthorized' },
        { status: 401 }
      );
    }

    const proposalId = parseInt(params.id);
    if (isNaN(proposalId)) {
      return NextResponse.json(
        { error: 'Invalid proposal ID' },
        { status: 400 }
      );
    }

    // Check if user is the author
    const proposal = await db
      .select({ authorId: proposals.authorId })
      .from(proposals)
      .where(eq(proposals.id, proposalId))
      .limit(1);

    if (proposal.length === 0) {
      return NextResponse.json(
        { error: 'Proposal not found' },
        { status: 404 }
      );
    }

    if (proposal[0].authorId !== session.userId) {
      return NextResponse.json(
        { error: 'You can only delete your own proposals' },
        { status: 403 }
      );
    }

    // Delete proposal (cascades to votes and comments)
    await db.delete(proposals).where(eq(proposals.id, proposalId));

    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('Failed to delete proposal:', error);
    return NextResponse.json(
      { error: 'Failed to delete proposal' },
      { status: 500 }
    );
  }
}
```

`dahao_0/src/app/api/governance/proposals/route.ts`:

```ts
import { NextRequest, NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { getSession } from '@/lib/auth/session';
import matter from 'gray-matter';

const REPO_OWNER = process.env.GITHUB_REPO_OWNER || 'dahao-dao';
const REPO_NAME = process.env.GITHUB_REPO_NAME || 'dahao';
const PROPOSALS_PATH = 'governance/proposals';

async function getOctokit(request: NextRequest) {
  const session = await getSession(request);
  if (!session?.accessToken) {
    throw new Error('Unauthorized');
  }
  return new Octokit({ auth: session.accessToken });
}

// GET /api/governance/proposals - List all proposals
export async function GET(request: NextRequest) {
  try {
    const octokit = await getOctokit(request);
    const searchParams = request.nextUrl.searchParams;
    const status = searchParams.get('status');
    
    const { data } = await octokit.repos.getContent({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: PROPOSALS_PATH,
    });

    if (Array.isArray(data)) {
      const proposals = await Promise.all(
        data
          .filter(file => file.type === 'file' && file.name.endsWith('.md'))
          .map(async (file) => {
            const fileData = await octokit.repos.getContent({
              owner: REPO_OWNER,
              repo: REPO_NAME,
              path: file.path,
            });

            if ('content' in fileData.data) {
              const content = Buffer.from(fileData.data.content, 'base64').toString('utf-8');
              const { data: frontmatter, content: body } = matter(content);
              
              if (status && frontmatter.status !== status) {
                return null;
              }
              
              return {
                id: file.path.replace(`${PROPOSALS_PATH}/`, '').replace('.md', ''),
                title: frontmatter.title || 'Untitled',
                description: body.substring(0, 200) + '...',
                author: frontmatter.author || 'Unknown',
                status: frontmatter.status || 'draft',
                type: frontmatter.type || 'standard',
                createdAt: frontmatter.createdAt || new Date().toISOString(),
                votingEndsAt: frontmatter.votingEndsAt || new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
                votes: frontmatter.votes || { for: 0, against: 0, abstain: 0 },
                quorum: frontmatter.quorum || 10,
                threshold: frontmatter.threshold || 66,
              };
            }
          })
      );

      return NextResponse.json(proposals.filter(Boolean));
    }

    return NextResponse.json([]);
  } catch (error) {
    console.error('Governance API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}

// POST /api/governance/proposals - Create new proposal
export async function POST(request: NextRequest) {
  try {
    const octokit = await getOctokit(request);
    const session = await getSession(request);
    const body = await request.json();
    
    const {
      title,
      description,
      type = 'standard',
      votingEndsAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString(),
      quorum = 10,
      threshold = 66,
    } = body;

    const proposalId = `${title.toLowerCase().replace(/\s+/g, '-')}-${Date.now()}`;
    const filePath = `${PROPOSALS_PATH}/${proposalId}.md`;

    const frontmatter = {
      title,
      author: session?.user?.username || 'Unknown',
      status: 'draft',
      type,
      createdAt: new Date().toISOString(),
      votingEndsAt,
      votes: { for: 0, against: 0, abstain: 0 },
      quorum,
      threshold,
    };

    const fileContent = matter.stringify(description, frontmatter);

    const { data } = await octokit.repos.createOrUpdateFileContents({
      owner: REPO_OWNER,
      repo: REPO_NAME,
      path: filePath,
      message: `Create proposal: ${title}`,
      content: Buffer.from(fileContent).toString('base64'),
    });

    return NextResponse.json({
      id: proposalId,
      path: filePath,
      sha: data.content?.sha,
    });
  } catch (error) {
    console.error('Governance API error:', error);
    if (error instanceof Error && error.message === 'Unauthorized') {
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }
    return NextResponse.json(
      { error: 'Internal server error' },
      { status: 500 }
    );
  }
}
```

`dahao_0/src/app/constitution/[sectionId]/page.tsx`:

```tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { DocumentViewer } from '@/components/constitution/DocumentViewer';
import { DocumentEditor } from '@/components/constitution/DocumentEditor';
import { DiffViewer } from '@/components/constitution/DiffViewer';
import { useDocument } from '@/hooks/useDocument';
import { ArrowLeftIcon, PencilIcon, ClockIcon } from '@heroicons/react/24/outline';

const SectionPage: React.FC = () => {
  const params = useParams();
  const router = useRouter();
  const sectionId = params.sectionId as string;
  const [isEditMode, setIsEditMode] = useState(false);
  const [showHistory, setShowHistory] = useState(false);
  const [compareVersion, setCompareVersion] = useState<string | null>(null);

  // Mock document path - in real app, map sectionId to actual file path
  const documentPath = `constitution/${sectionId}.yaml`;
  const repoPath = process.env.NEXT_PUBLIC_REPO_PATH || '.';

  const {
    document,
    isLoading,
    error,
    isDirty,
    loadHistory,
    saveDocument,
    getDocumentDiff,
  } = useDocument(documentPath, repoPath);

  useEffect(() => {
    loadHistory();
  }, [loadHistory]);

  const handleSave = async (content: string) => {
    const message = `Update ${document?.metadata.title || sectionId}`;
    await saveDocument(content, message);
    setIsEditMode(false);
  };

  const handleCompare = async (commitHash: string) => {
    setCompareVersion(commitHash);
    // Load diff for comparison
  };

  if (isLoading) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 flex items-center justify-center">
        <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600"></div>
      </div>
    );
  }

  if (error) {
    return (
      <div className="min-h-screen bg-gray-50 dark:bg-gray-900 p-8">
        <div className="max-w-2xl mx-auto">
          <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded">
            Error: {error}
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-6 flex items-center justify-between">
          <div className="flex items-center gap-4">
            <button
              onClick={() => router.push('/constitution')}
              className="flex items-center gap-2 text-gray-600 dark:text-gray-400 hover:text-gray-900 dark:hover:text-white"
            >
              <ArrowLeftIcon className="h-5 w-5" />
              Back to Constitution
            </button>
            <h1 className="text-2xl font-bold text-gray-900 dark:text-white">
              {document?.metadata.title || 'Loading...'}
            </h1>
          </div>

          <div className="flex items-center gap-4">
            <button
              onClick={() => setShowHistory(!showHistory)}
              className="flex items-center gap-2 px-4 py-2 text-gray-700 dark:text-gray-300 bg-white dark:bg-gray-800 rounded-md shadow hover:bg-gray-50 dark:hover:bg-gray-700"
            >
              <ClockIcon className="h-5 w-5" />
              History
            </button>
            <button
              onClick={() => setIsEditMode(!isEditMode)}
              className="flex items-center gap-2 px-4 py-2 bg-blue-600 text-white rounded-md shadow hover:bg-blue-700"
            >
              <PencilIcon className="h-5 w-5" />
              {isEditMode ? 'Cancel Edit' : 'Edit'}
            </button>
          </div>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-4 gap-8">
          <div className={showHistory ? 'lg:col-span-3' : 'lg:col-span-4'}>
            {isEditMode && document ? (
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg h-[600px]">
                <DocumentEditor
                  initialContent={document.content}
                  onSave={handleSave}
                  title={document.metadata.title}
                />
              </div>
            ) : compareVersion ? (
              <DiffViewer
                oldContent="Original content here"
                newContent={document?.content || ''}
                oldTitle={`Version at ${compareVersion}`}
                newTitle="Current Version"
              />
            ) : (
              <DocumentViewer
                content={document?.content || ''}
                metadata={document?.metadata}
              />
            )}
          </div>

          {showHistory && document?.history && (
            <div className="lg:col-span-1">
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4">
                <h3 className="text-lg font-semibold text-gray-900 dark:text-white mb-4">
                  Version History
                </h3>
                <div className="space-y-3">
                  {document.history.map((commit) => (
                    <div
                      key={commit.hash}
                      className="p-3 border border-gray-200 dark:border-gray-700 rounded-md hover:bg-gray-50 dark:hover:bg-gray-700 cursor-pointer"
                      onClick={() => handleCompare(commit.hash)}
                    >
                      <p className="text-sm font-medium text-gray-900 dark:text-white">
                        {commit.message}
                      </p>
                      <p className="text-xs text-gray-500 dark:text-gray-400 mt-1">
                        {new Date(commit.date).toLocaleDateString()} by {commit.author}
                      </p>
                    </div>
                  ))}
                </div>
              </div>
            </div>
          )}
        </div>
      </div>
    </div>
  );
};

export default SectionPage;
```

`dahao_0/src/app/constitution/page.tsx`:

```tsx
'use client';

import React, { useState, useEffect } from 'react';
import { SectionBrowser, Section } from '@/components/constitution/SectionBrowser';
import { DocumentViewer } from '@/components/constitution/DocumentViewer';
import { useRouter } from 'next/navigation';

const ConstitutionPage: React.FC = () => {
  const router = useRouter();
  const [sections, setSections] = useState<Section[]>([]);
  const [selectedSection, setSelectedSection] = useState<Section | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Load constitution structure
    const loadSections = async () => {
      try {
        const response = await fetch('/api/constitution/structure');
        if (response.ok) {
          const data = await response.json();
          setSections(data.sections);
        }
      } catch (error) {
        console.error('Failed to load constitution structure:', error);
      } finally {
        setIsLoading(false);
      }
    };

    loadSections();
  }, []);

  const handleSectionSelect = (section: Section) => {
    setSelectedSection(section);
    if (section.isFile) {
      router.push(`/constitution/${section.id}`);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <div className="mb-8">
          <h1 className="text-4xl font-bold text-gray-900 dark:text-white">
            Constitution of Dahao
          </h1>
          <p className="mt-2 text-lg text-gray-600 dark:text-gray-400">
            Browse and view the constitutional documents
          </p>
        </div>

        <div className="grid grid-cols-1 lg:grid-cols-3 gap-8">
          <div className="lg:col-span-1">
            {isLoading ? (
              <div className="animate-pulse">
                <div className="h-64 bg-gray-200 dark:bg-gray-700 rounded-lg"></div>
              </div>
            ) : (
              <SectionBrowser
                sections={sections}
                onSelectSection={handleSectionSelect}
                selectedSectionId={selectedSection?.id}
              />
            )}
          </div>

          <div className="lg:col-span-2">
            {selectedSection ? (
              <DocumentViewer
                title={selectedSection.title}
                content={`# ${selectedSection.title}\n\nNavigate to view the full document.`}
              />
            ) : (
              <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg p-8 text-center">
                <h3 className="text-xl font-semibold text-gray-900 dark:text-white mb-4">
                  Welcome to the Constitution
                </h3>
                <p className="text-gray-600 dark:text-gray-400">
                  Select a section from the browser to view its contents.
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default ConstitutionPage;
```

`dahao_0/src/app/globals.css`:

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 222.2 84% 4.9%;
    --card: 0 0% 100%;
    --card-foreground: 222.2 84% 4.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 222.2 84% 4.9%;
    --primary: 222.2 47.4% 11.2%;
    --primary-foreground: 210 40% 98%;
    --secondary: 210 40% 96.1%;
    --secondary-foreground: 222.2 47.4% 11.2%;
    --muted: 210 40% 96.1%;
    --muted-foreground: 215.4 16.3% 46.9%;
    --accent: 210 40% 96.1%;
    --accent-foreground: 222.2 47.4% 11.2%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;
    --border: 214.3 31.8% 91.4%;
    --input: 214.3 31.8% 91.4%;
    --ring: 222.2 84% 4.9%;
    --radius: 0.5rem;
  }

  .dark {
    --background: 222.2 84% 4.9%;
    --foreground: 210 40% 98%;
    --card: 222.2 84% 4.9%;
    --card-foreground: 210 40% 98%;
    --popover: 222.2 84% 4.9%;
    --popover-foreground: 210 40% 98%;
    --primary: 210 40% 98%;
    --primary-foreground: 222.2 47.4% 11.2%;
    --secondary: 217.2 32.6% 17.5%;
    --secondary-foreground: 210 40% 98%;
    --muted: 217.2 32.6% 17.5%;
    --muted-foreground: 215 20.2% 65.1%;
    --accent: 217.2 32.6% 17.5%;
    --accent-foreground: 210 40% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;
    --border: 217.2 32.6% 17.5%;
    --input: 217.2 32.6% 17.5%;
    --ring: 212.7 26.8% 83.9%;
  }
}

@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

@layer components {
  .prose {
    @apply text-base leading-7;
  }
  
  .prose p {
    @apply my-4;
  }
  
  .prose h1 {
    @apply text-3xl font-bold my-6;
  }
  
  .prose h2 {
    @apply text-2xl font-semibold my-5;
  }
  
  .prose h3 {
    @apply text-xl font-semibold my-4;
  }
  
  .prose ul {
    @apply list-disc list-inside my-4 space-y-2;
  }
  
  .prose ol {
    @apply list-decimal list-inside my-4 space-y-2;
  }
  
  .prose blockquote {
    @apply border-l-4 border-muted-foreground/20 pl-4 italic my-4;
  }
  
  .prose code {
    @apply bg-muted px-1.5 py-0.5 rounded text-sm font-mono;
  }
  
  .prose pre {
    @apply bg-muted p-4 rounded-lg overflow-x-auto my-4;
  }
  
  .prose pre code {
    @apply bg-transparent p-0;
  }
}
```

`dahao_0/src/app/layout.tsx`:

```tsx
import type { Metadata } from 'next'
import { Inter } from 'next/font/google'
import './globals.css'
import { Header } from '@/components/layout/Header'

const inter = Inter({ subsets: ['latin'] })

export const metadata: Metadata = {
  title: 'DaHao DAO - Decentralized Autonomous Organization',
  description: 'A decentralized platform for community governance and collaboration',
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang="en">
      <body className={inter.className}>
        <Header />
        <main className="min-h-screen">
          {children}
        </main>
      </body>
    </html>
  )
}
```

`dahao_0/src/app/page.tsx`:

```tsx
'use client';

import Link from 'next/link';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { ArrowRightIcon, FileTextIcon, MessageSquareIcon, VoteIcon } from 'lucide-react';
import { useEffect, useState } from 'react';
import { Session } from '@/lib/auth/types';

export default function Home() {
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    fetch('/api/auth/session')
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        setSession(data);
        setLoading(false);
      })
      .catch(() => setLoading(false));
  }, []);

  const features = [
    {
      icon: FileTextIcon,
      title: 'Constitution',
      description: 'Read and understand our community guidelines and principles',
      href: '/constitution',
    },
    {
      icon: VoteIcon,
      title: 'Governance',
      description: 'Participate in decision-making through proposals and voting',
      href: '/governance',
    },
    {
      icon: MessageSquareIcon,
      title: 'Forum',
      description: 'Engage in discussions with the community',
      href: '/forum',
    },
  ];

  return (
    <div className="container mx-auto px-4 py-16">
      <div className="max-w-4xl mx-auto">
        <div className="text-center mb-12">
          <h1 className="text-4xl font-bold tracking-tight mb-4">
            Welcome to DaHao DAO
          </h1>
          <p className="text-xl text-muted-foreground mb-8">
            A decentralized platform for community governance and collaboration
          </p>
          
          {loading ? (
            <div className="inline-block h-10 w-32 animate-pulse bg-muted rounded" />
          ) : session ? (
            <div className="space-y-2">
              <p className="text-lg">
                Welcome back, <span className="font-semibold">{session.user.name || session.user.username}</span>!
              </p>
              <Button asChild>
                <Link href="/governance">
                  Go to Governance
                  <ArrowRightIcon className="ml-2 h-4 w-4" />
                </Link>
              </Button>
            </div>
          ) : (
            <div className="space-y-4">
              <p className="text-lg text-muted-foreground">
                Sign in to participate in governance and join the community
              </p>
              <Button asChild size="lg">
                <Link href="/api/auth/github">
                  Get Started
                  <ArrowRightIcon className="ml-2 h-4 w-4" />
                </Link>
              </Button>
            </div>
          )}
        </div>

        <div className="grid gap-6 md:grid-cols-3">
          {features.map((feature) => {
            const Icon = feature.icon;
            return (
              <Card key={feature.href} className="hover:shadow-lg transition-shadow">
                <CardHeader>
                  <Icon className="h-8 w-8 mb-2 text-primary" />
                  <CardTitle>{feature.title}</CardTitle>
                  <CardDescription>{feature.description}</CardDescription>
                </CardHeader>
                <CardContent>
                  <Button asChild variant="outline" className="w-full">
                    <Link href={feature.href}>
                      Explore
                      <ArrowRightIcon className="ml-2 h-4 w-4" />
                    </Link>
                  </Button>
                </CardContent>
              </Card>
            );
          })}
        </div>

        <div className="mt-16 text-center">
          <h2 className="text-2xl font-semibold mb-4">About DaHao DAO</h2>
          <div className="prose prose-gray mx-auto">
            <p className="text-muted-foreground">
              DaHao DAO is a decentralized autonomous organization that empowers communities
              to make collective decisions through transparent governance mechanisms.
              Our platform enables members to create proposals, vote on important matters,
              and engage in meaningful discussions.
            </p>
            <p className="text-muted-foreground mt-4">
              Built on principles of transparency, inclusivity, and democratic participation,
              we're creating a space where every voice matters and collective wisdom drives progress.
            </p>
          </div>
        </div>
      </div>
    </div>
  );
}
```

`dahao_0/src/components/auth/LoginButton.tsx`:

```tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { GitHubLogoIcon } from '@radix-ui/react-icons';

interface LoginButtonProps {
  className?: string;
}

export function LoginButton({ className }: LoginButtonProps) {
  const [isLoading, setIsLoading] = useState(false);
  const router = useRouter();

  const handleLogin = () => {
    setIsLoading(true);
    // Redirect to GitHub OAuth
    window.location.href = '/api/auth/github';
  };

  return (
    <Button
      onClick={handleLogin}
      disabled={isLoading}
      className={className}
      variant="outline"
    >
      <GitHubLogoIcon className="mr-2 h-4 w-4" />
      {isLoading ? 'Redirecting...' : 'Sign in with GitHub'}
    </Button>
  );
}
```

`dahao_0/src/components/constitution/DiffViewer.tsx`:

```tsx
'use client';

import React from 'react';
import { diffLines, Change } from 'diff';

interface DiffViewerProps {
  oldContent: string;
  newContent: string;
  oldTitle?: string;
  newTitle?: string;
}

export const DiffViewer: React.FC<DiffViewerProps> = ({
  oldContent,
  newContent,
  oldTitle = 'Original',
  newTitle = 'Modified'
}) => {
  const changes = diffLines(oldContent, newContent);

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg overflow-hidden">
      <div className="grid grid-cols-2 border-b border-gray-200 dark:border-gray-700">
        <div className="px-4 py-3 bg-red-50 dark:bg-red-900/20">
          <h3 className="text-sm font-semibold text-red-700 dark:text-red-400">
            {oldTitle}
          </h3>
        </div>
        <div className="px-4 py-3 bg-green-50 dark:bg-green-900/20 border-l border-gray-200 dark:border-gray-700">
          <h3 className="text-sm font-semibold text-green-700 dark:text-green-400">
            {newTitle}
          </h3>
        </div>
      </div>

      <div className="overflow-x-auto">
        <table className="w-full">
          <tbody>
            {changes.map((change, index) => (
              <DiffLine key={index} change={change} />
            ))}
          </tbody>
        </table>
      </div>
    </div>
  );
};

const DiffLine: React.FC<{ change: Change }> = ({ change }) => {
  const lines = change.value.split('\n').filter((line, index, arr) => 
    index < arr.length - 1 || line.length > 0
  );

  return (
    <>
      {lines.map((line, lineIndex) => (
        <tr
          key={lineIndex}
          className={
            change.added
              ? 'bg-green-50 dark:bg-green-900/20'
              : change.removed
              ? 'bg-red-50 dark:bg-red-900/20'
              : ''
          }
        >
          <td className="w-12 px-2 py-1 text-right text-xs text-gray-500 dark:text-gray-400 select-none">
            {!change.added && lineIndex + 1}
          </td>
          <td className="w-12 px-2 py-1 text-right text-xs text-gray-500 dark:text-gray-400 select-none border-r border-gray-200 dark:border-gray-700">
            {!change.removed && lineIndex + 1}
          </td>
          <td className="px-4 py-1 font-mono text-sm whitespace-pre-wrap">
            <span
              className={
                change.added
                  ? 'text-green-700 dark:text-green-400'
                  : change.removed
                  ? 'text-red-700 dark:text-red-400'
                  : 'text-gray-700 dark:text-gray-300'
              }
            >
              {change.added ? '+ ' : change.removed ? '- ' : '  '}
              {line}
            </span>
          </td>
        </tr>
      ))}
    </>
  );
};
```

`dahao_0/src/components/constitution/DocumentEditor.tsx`:

```tsx
'use client';

import React, { useState, useCallback } from 'react';
import Editor from '@monaco-editor/react';
import { DocumentViewer } from './DocumentViewer';
import yaml from 'js-yaml';

interface DocumentEditorProps {
  initialContent: string;
  onSave: (content: string) => Promise<void>;
  title?: string;
}

export const DocumentEditor: React.FC<DocumentEditorProps> = ({
  initialContent,
  onSave,
  title
}) => {
  const [content, setContent] = useState(initialContent);
  const [isPreview, setIsPreview] = useState(false);
  const [isSaving, setIsSaving] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const handleSave = useCallback(async () => {
    setIsSaving(true);
    setError(null);
    try {
      // Validate YAML
      yaml.load(content);
      await onSave(content);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to save');
    } finally {
      setIsSaving(false);
    }
  }, [content, onSave]);

  const getPreviewContent = () => {
    try {
      const data = yaml.load(content) as any;
      return data.content || data.description || JSON.stringify(data, null, 2);
    } catch {
      return 'Invalid YAML format';
    }
  };

  const getMetadata = () => {
    try {
      const data = yaml.load(content) as any;
      const { content: _, description: __, ...metadata } = data;
      return metadata;
    } catch {
      return {};
    }
  };

  return (
    <div className="h-full flex flex-col">
      <div className="flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700">
        <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
          {title || 'Document Editor'}
        </h2>
        <div className="flex items-center gap-4">
          <div className="flex rounded-md shadow-sm" role="group">
            <button
              type="button"
              onClick={() => setIsPreview(false)}
              className={`px-4 py-2 text-sm font-medium rounded-l-lg border ${
                !isPreview
                  ? 'bg-blue-600 text-white border-blue-600'
                  : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-600'
              }`}
            >
              Edit
            </button>
            <button
              type="button"
              onClick={() => setIsPreview(true)}
              className={`px-4 py-2 text-sm font-medium rounded-r-lg border ${
                isPreview
                  ? 'bg-blue-600 text-white border-blue-600'
                  : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-50 dark:bg-gray-700 dark:text-gray-300 dark:border-gray-600'
              }`}
            >
              Preview
            </button>
          </div>
          <button
            onClick={handleSave}
            disabled={isSaving}
            className="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 disabled:opacity-50 disabled:cursor-not-allowed"
          >
            {isSaving ? 'Saving...' : 'Save'}
          </button>
        </div>
      </div>

      {error && (
        <div className="mx-4 mt-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded">
          {error}
        </div>
      )}

      <div className="flex-1 overflow-hidden">
        {isPreview ? (
          <div className="h-full overflow-auto p-4">
            <DocumentViewer
              content={getPreviewContent()}
              metadata={getMetadata()}
            />
          </div>
        ) : (
          <Editor
            height="100%"
            defaultLanguage="yaml"
            value={content}
            onChange={(value) => setContent(value || '')}
            theme="vs-dark"
            options={{
              minimap: { enabled: false },
              fontSize: 14,
              wordWrap: 'on',
              lineNumbers: 'on',
              scrollBeyondLastLine: false,
              automaticLayout: true,
            }}
          />
        )}
      </div>
    </div>
  );
};
```

`dahao_0/src/components/constitution/DocumentViewer.tsx`:

```tsx
'use client';

import React from 'react';
import ReactMarkdown from 'react-markdown';

interface DocumentViewerProps {
  content: string;
  title?: string;
  metadata?: Record<string, any>;
}

export const DocumentViewer: React.FC<DocumentViewerProps> = ({
  content,
  title,
  metadata
}) => {
  return (
    <div className="max-w-4xl mx-auto p-6 bg-white dark:bg-gray-800 rounded-lg shadow-lg">
      {title && (
        <h1 className="text-3xl font-bold mb-6 text-gray-900 dark:text-white">
          {title}
        </h1>
      )}
      
      {metadata && Object.keys(metadata).length > 0 && (
        <div className="mb-6 p-4 bg-gray-100 dark:bg-gray-700 rounded-md">
          <h3 className="text-sm font-semibold text-gray-600 dark:text-gray-300 mb-2">
            Metadata
          </h3>
          <dl className="grid grid-cols-1 sm:grid-cols-2 gap-2">
            {Object.entries(metadata).map(([key, value]) => (
              <div key={key}>
                <dt className="text-sm font-medium text-gray-500 dark:text-gray-400">
                  {key}:
                </dt>
                <dd className="text-sm text-gray-900 dark:text-white">
                  {typeof value === 'object' ? JSON.stringify(value) : String(value)}
                </dd>
              </div>
            ))}
          </dl>
        </div>
      )}
      
      <div className="prose prose-lg dark:prose-invert max-w-none">
        <ReactMarkdown>{content}</ReactMarkdown>
      </div>
    </div>
  );
};
```

`dahao_0/src/components/constitution/SectionBrowser.tsx`:

```tsx
'use client';

import React, { useState } from 'react';
import { ChevronRightIcon, ChevronDownIcon, DocumentTextIcon, FolderIcon, FolderOpenIcon } from '@heroicons/react/24/outline';

export interface Section {
  id: string;
  title: string;
  path: string;
  children?: Section[];
  isFile?: boolean;
}

interface SectionBrowserProps {
  sections: Section[];
  onSelectSection: (section: Section) => void;
  selectedSectionId?: string;
}

const SectionItem: React.FC<{
  section: Section;
  onSelect: (section: Section) => void;
  selectedId?: string;
  level?: number;
}> = ({ section, onSelect, selectedId, level = 0 }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  const hasChildren = section.children && section.children.length > 0;
  const isSelected = section.id === selectedId;

  const handleClick = () => {
    if (hasChildren) {
      setIsExpanded(!isExpanded);
    }
    onSelect(section);
  };

  return (
    <div>
      <div
        className={`flex items-center px-3 py-2 cursor-pointer hover:bg-gray-100 dark:hover:bg-gray-700 ${
          isSelected ? 'bg-blue-100 dark:bg-blue-900' : ''
        }`}
        style={{ paddingLeft: `${level * 20 + 12}px` }}
        onClick={handleClick}
      >
        {hasChildren && (
          <span className="mr-1">
            {isExpanded ? (
              <ChevronDownIcon className="h-4 w-4 text-gray-500" />
            ) : (
              <ChevronRightIcon className="h-4 w-4 text-gray-500" />
            )}
          </span>
        )}
        {!hasChildren && !section.isFile && (
          <span className="mr-1 ml-5" />
        )}
        <span className="mr-2">
          {section.isFile ? (
            <DocumentTextIcon className="h-5 w-5 text-gray-400" />
          ) : isExpanded ? (
            <FolderOpenIcon className="h-5 w-5 text-gray-400" />
          ) : (
            <FolderIcon className="h-5 w-5 text-gray-400" />
          )}
        </span>
        <span className={`text-sm ${isSelected ? 'font-semibold text-blue-600 dark:text-blue-400' : 'text-gray-700 dark:text-gray-300'}`}>
          {section.title}
        </span>
      </div>
      {hasChildren && isExpanded && (
        <div>
          {section.children!.map((child) => (
            <SectionItem
              key={child.id}
              section={child}
              onSelect={onSelect}
              selectedId={selectedId}
              level={level + 1}
            />
          ))}
        </div>
      )}
    </div>
  );
};

export const SectionBrowser: React.FC<SectionBrowserProps> = ({
  sections,
  onSelectSection,
  selectedSectionId
}) => {
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg shadow-lg">
      <div className="p-4 border-b border-gray-200 dark:border-gray-700">
        <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
          Constitution Sections
        </h3>
      </div>
      <div className="max-h-[600px] overflow-y-auto">
        {sections.map((section) => (
          <SectionItem
            key={section.id}
            section={section}
            onSelect={onSelectSection}
            selectedId={selectedSectionId}
          />
        ))}
      </div>
    </div>
  );
};
```

`dahao_0/src/components/layout/Header.tsx`:

```tsx
'use client';

import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { LoginButton } from '@/components/auth/LoginButton';
import { Button } from '@/components/ui/button';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from '@/components/ui/dropdown-menu';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { useEffect, useState } from 'react';
import { Session } from '@/lib/auth/types';

export function Header() {
  const pathname = usePathname();
  const [session, setSession] = useState<Session | null>(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    // Check for session
    fetch('/api/auth/session')
      .then(res => res.ok ? res.json() : null)
      .then(data => {
        setSession(data);
        setLoading(false);
      })
      .catch(() => setLoading(false));
  }, []);

  const handleLogout = async () => {
    await fetch('/api/auth/logout', { method: 'POST' });
    setSession(null);
    window.location.href = '/';
  };

  const navItems = [
    { href: '/', label: 'Home' },
    { href: '/governance', label: 'Governance' },
    { href: '/constitution', label: 'Constitution' },
    { href: '/forum', label: 'Forum' },
  ];

  return (
    <header className="border-b">
      <div className="container mx-auto px-4 py-4">
        <nav className="flex items-center justify-between">
          <div className="flex items-center space-x-6">
            <Link href="/" className="text-xl font-bold">
              DaHao DAO
            </Link>
            <div className="hidden md:flex items-center space-x-4">
              {navItems.map((item) => (
                <Link
                  key={item.href}
                  href={item.href}
                  className={`text-sm font-medium transition-colors hover:text-primary ${
                    pathname === item.href
                      ? 'text-foreground'
                      : 'text-muted-foreground'
                  }`}
                >
                  {item.label}
                </Link>
              ))}
            </div>
          </div>

          <div className="flex items-center space-x-4">
            {loading ? (
              <div className="h-8 w-8 animate-pulse bg-muted rounded-full" />
            ) : session ? (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" className="relative h-8 w-8 rounded-full">
                    <Avatar className="h-8 w-8">
                      <AvatarImage
                        src={session.user.avatarUrl || undefined}
                        alt={session.user.username}
                      />
                      <AvatarFallback>
                        {session.user.username.charAt(0).toUpperCase()}
                      </AvatarFallback>
                    </Avatar>
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent className="w-56" align="end" forceMount>
                  <DropdownMenuItem className="font-normal">
                    <div className="flex flex-col space-y-1">
                      <p className="text-sm font-medium leading-none">
                        {session.user.name || session.user.username}
                      </p>
                      <p className="text-xs leading-none text-muted-foreground">
                        {session.user.email}
                      </p>
                    </div>
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem asChild>
                    <Link href="/profile">Profile</Link>
                  </DropdownMenuItem>
                  <DropdownMenuItem asChild>
                    <Link href="/settings">Settings</Link>
                  </DropdownMenuItem>
                  <DropdownMenuSeparator />
                  <DropdownMenuItem onClick={handleLogout}>
                    Log out
                  </DropdownMenuItem>
                </DropdownMenuContent>
              </DropdownMenu>
            ) : (
              <LoginButton />
            )}
          </div>
        </nav>
      </div>
    </header>
  );
}
```

`dahao_0/src/config/env.ts`:

```ts
export interface EnvConfig {
  GITHUB_TOKEN?: string;
  GITLAB_TOKEN?: string;
  GITEA_TOKEN?: string;
  GIT_PROVIDER?: 'github' | 'gitlab' | 'gitea';
  GIT_OWNER?: string;
  GIT_BASE_URL?: string; // For self-hosted instances
}

export function getEnvConfig(): EnvConfig {
  return {
    GITHUB_TOKEN: process.env.GITHUB_TOKEN,
    GITLAB_TOKEN: process.env.GITLAB_TOKEN,
    GITEA_TOKEN: process.env.GITEA_TOKEN,
    GIT_PROVIDER: (process.env.GIT_PROVIDER as EnvConfig['GIT_PROVIDER']) || 'github',
    GIT_OWNER: process.env.GIT_OWNER,
    GIT_BASE_URL: process.env.GIT_BASE_URL,
  };
}

export function validateEnvConfig(config: EnvConfig): void {
  const provider = config.GIT_PROVIDER || 'github';
  
  switch (provider) {
    case 'github':
      if (!config.GITHUB_TOKEN) {
        throw new Error('GITHUB_TOKEN environment variable is required for GitHub provider');
      }
      break;
    case 'gitlab':
      if (!config.GITLAB_TOKEN) {
        throw new Error('GITLAB_TOKEN environment variable is required for GitLab provider');
      }
      break;
    case 'gitea':
      if (!config.GITEA_TOKEN) {
        throw new Error('GITEA_TOKEN environment variable is required for Gitea provider');
      }
      if (!config.GIT_BASE_URL) {
        throw new Error('GIT_BASE_URL environment variable is required for Gitea provider');
      }
      break;
    default:
      throw new Error(`Unknown GIT_PROVIDER: ${provider}`);
  }
  
  if (!config.GIT_OWNER) {
    throw new Error('GIT_OWNER environment variable is required');
  }
}

export function getProviderToken(config: EnvConfig): string {
  const provider = config.GIT_PROVIDER || 'github';
  
  switch (provider) {
    case 'github':
      return config.GITHUB_TOKEN!;
    case 'gitlab':
      return config.GITLAB_TOKEN!;
    case 'gitea':
      return config.GITEA_TOKEN!;
    default:
      throw new Error(`Unknown provider: ${provider}`);
  }
}
```

`dahao_0/src/hooks/useDocument.ts`:

```ts
import { useState, useCallback } from 'react';
import { useYAMLData } from './useYAMLData';
import { useGitRepo } from './useGitRepo';

export interface DocumentMetadata {
  title: string;
  version: string;
  lastModified: string;
  author?: string;
  tags?: string[];
}

export interface Document {
  id: string;
  path: string;
  content: string;
  metadata: DocumentMetadata;
  history?: Array<{
    hash: string;
    date: string;
    message: string;
    author: string;
  }>;
}

export const useDocument = (documentPath: string, repoPath: string) => {
  const { data: yamlData, isLoading: yamlLoading, error: yamlError, saveData, isDirty } = useYAMLData(documentPath);
  const { getCommits, commit, getDiff } = useGitRepo(repoPath);
  const [history, setHistory] = useState<Document['history']>([]);

  const loadHistory = useCallback(async () => {
    try {
      const commits = await getCommits(documentPath, 20);
      setHistory(commits);
    } catch (err) {
      console.error('Failed to load document history:', err);
    }
  }, [documentPath, getCommits]);

  const saveDocument = useCallback(async (content: string, commitMessage: string) => {
    await saveData(content);
    await commit(commitMessage, [documentPath]);
    await loadHistory();
  }, [saveData, commit, documentPath, loadHistory]);

  const getDocumentDiff = useCallback(async (commitHash?: string) => {
    return await getDiff(documentPath, commitHash);
  }, [getDiff, documentPath]);

  const document: Document | null = yamlData ? {
    id: documentPath.replace(/[^a-zA-Z0-9]/g, '-'),
    path: documentPath,
    content: yamlData.content.content || yamlData.raw,
    metadata: {
      title: yamlData.content.title || 'Untitled',
      version: yamlData.content.version || '1.0.0',
      lastModified: yamlData.content.lastModified || new Date().toISOString(),
      author: yamlData.content.author,
      tags: yamlData.content.tags,
    },
    history,
  } : null;

  return {
    document,
    isLoading: yamlLoading,
    error: yamlError,
    isDirty,
    loadHistory,
    saveDocument,
    getDocumentDiff,
  };
};
```

`dahao_0/src/hooks/useGitRepo.ts`:

```ts
import { useState, useCallback } from 'react';

export interface GitCommit {
  hash: string;
  author: string;
  date: string;
  message: string;
}

export interface GitStatus {
  modified: string[];
  added: string[];
  deleted: string[];
  untracked: string[];
}

export const useGitRepo = (repoPath: string) => {
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const executeGitCommand = useCallback(async (command: string[]) => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch('/api/git', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ command, repoPath }),
      });

      if (!response.ok) {
        throw new Error(`Git command failed: ${response.statusText}`);
      }

      const data = await response.json();
      return data.output;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Git operation failed';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [repoPath]);

  const getStatus = useCallback(async (): Promise<GitStatus> => {
    const output = await executeGitCommand(['status', '--porcelain']);
    const status: GitStatus = {
      modified: [],
      added: [],
      deleted: [],
      untracked: [],
    };

    output.split('\n').forEach((line: string) => {
      if (!line.trim()) return;
      const [statusCode, ...filePathParts] = line.trim().split(' ');
      const filePath = filePathParts.join(' ');

      if (statusCode === 'M') status.modified.push(filePath);
      else if (statusCode === 'A') status.added.push(filePath);
      else if (statusCode === 'D') status.deleted.push(filePath);
      else if (statusCode === '??') status.untracked.push(filePath);
    });

    return status;
  }, [executeGitCommand]);

  const getCommits = useCallback(async (filePath?: string, limit = 10): Promise<GitCommit[]> => {
    const args = ['log', `--max-count=${limit}`, '--pretty=format:%H|%an|%ad|%s', '--date=iso'];
    if (filePath) args.push('--', filePath);

    const output = await executeGitCommand(args);
    return output.split('\n').filter(Boolean).map((line: string) => {
      const [hash, author, date, message] = line.split('|');
      return { hash, author, date, message };
    });
  }, [executeGitCommand]);

  const commit = useCallback(async (message: string, files: string[]) => {
    if (files.length > 0) {
      await executeGitCommand(['add', ...files]);
    }
    await executeGitCommand(['commit', '-m', message]);
  }, [executeGitCommand]);

  const push = useCallback(async (branch = 'main') => {
    await executeGitCommand(['push', 'origin', branch]);
  }, [executeGitCommand]);

  const pull = useCallback(async (branch = 'main') => {
    await executeGitCommand(['pull', 'origin', branch]);
  }, [executeGitCommand]);

  const getDiff = useCallback(async (filePath: string, commitHash?: string) => {
    const args = ['diff'];
    if (commitHash) args.push(commitHash);
    args.push('--', filePath);
    
    return await executeGitCommand(args);
  }, [executeGitCommand]);

  return {
    isLoading,
    error,
    getStatus,
    getCommits,
    commit,
    push,
    pull,
    getDiff,
  };
};
```

`dahao_0/src/hooks/useYAMLData.ts`:

```ts
import { useState, useCallback, useEffect } from 'react';
import yaml from 'js-yaml';

export interface YAMLDocument {
  content: any;
  raw: string;
  path: string;
}

export const useYAMLData = (filePath: string) => {
  const [data, setData] = useState<YAMLDocument | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [isDirty, setIsDirty] = useState(false);

  const loadData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const response = await fetch(`/api/documents/${encodeURIComponent(filePath)}`);
      if (!response.ok) {
        throw new Error(`Failed to load document: ${response.statusText}`);
      }

      const raw = await response.text();
      const content = yaml.load(raw);
      
      setData({
        content,
        raw,
        path: filePath,
      });
      setIsDirty(false);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to load YAML data';
      setError(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [filePath]);

  const saveData = useCallback(async (newContent: string) => {
    setIsLoading(true);
    setError(null);
    try {
      // Validate YAML
      const parsed = yaml.load(newContent);
      
      const response = await fetch(`/api/documents/${encodeURIComponent(filePath)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'text/plain' },
        body: newContent,
      });

      if (!response.ok) {
        throw new Error(`Failed to save document: ${response.statusText}`);
      }

      setData({
        content: parsed,
        raw: newContent,
        path: filePath,
      });
      setIsDirty(false);
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to save YAML data';
      setError(errorMessage);
      throw err;
    } finally {
      setIsLoading(false);
    }
  }, [filePath]);

  const updateData = useCallback((newContent: string) => {
    try {
      const parsed = yaml.load(newContent);
      setData(prev => prev ? {
        ...prev,
        content: parsed,
        raw: newContent,
      } : null);
      setIsDirty(true);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Invalid YAML format');
    }
  }, []);

  useEffect(() => {
    if (filePath) {
      loadData();
    }
  }, [filePath, loadData]);

  return {
    data,
    isLoading,
    error,
    isDirty,
    loadData,
    saveData,
    updateData,
  };
};
```

`dahao_0/src/lib/auth/github.ts`:

```ts
import { NextResponse } from 'next/server';

const GITHUB_CLIENT_ID = process.env.GITHUB_CLIENT_ID!;
const GITHUB_CLIENT_SECRET = process.env.GITHUB_CLIENT_SECRET!;
const GITHUB_REDIRECT_URI = process.env.GITHUB_REDIRECT_URI || 'http://localhost:3000/api/auth/github';

export function getGitHubAuthUrl() {
  const state = generateRandomState();
  const params = new URLSearchParams({
    client_id: GITHUB_CLIENT_ID,
    redirect_uri: GITHUB_REDIRECT_URI,
    scope: 'read:user user:email repo',
    state,
  });

  // Store state in cookie for CSRF protection
  const response = NextResponse.redirect(`https://github.com/login/oauth/authorize?${params}`);
  response.cookies.set('oauth_state', state, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: 60 * 10, // 10 minutes
  });

  return `https://github.com/login/oauth/authorize?${params}`;
}

export async function exchangeCodeForToken(code: string) {
  const response = await fetch('https://github.com/login/oauth/access_token', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
    },
    body: JSON.stringify({
      client_id: GITHUB_CLIENT_ID,
      client_secret: GITHUB_CLIENT_SECRET,
      code,
      redirect_uri: GITHUB_REDIRECT_URI,
    }),
  });

  if (!response.ok) {
    throw new Error('Failed to exchange code for token');
  }

  return response.json();
}

export async function getGitHubUser(accessToken: string) {
  const response = await fetch('https://api.github.com/user', {
    headers: {
      Authorization: `Bearer ${accessToken}`,
      Accept: 'application/vnd.github.v3+json',
    },
  });

  if (!response.ok) {
    throw new Error('Failed to get user info');
  }

  return response.json();
}

function generateRandomState() {
  const array = new Uint8Array(32);
  crypto.getRandomValues(array);
  return Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('');
}
```

`dahao_0/src/lib/auth/session.ts`:

```ts
import { cookies } from 'next/headers';
import { SignJWT, jwtVerify } from 'jose';
import { Session, User } from './types';
import { NextRequest } from 'next/server';

const secret = new TextEncoder().encode(
  process.env.JWT_SECRET || 'your-secret-key-change-in-production'
);

const SESSION_DURATION = 7 * 24 * 60 * 60 * 1000; // 7 days

export async function createSession(user: User): Promise<string> {
  const token = await new SignJWT({ userId: user.id })
    .setProtectedHeader({ alg: 'HS256' })
    .setIssuedAt()
    .setExpirationTime('7d')
    .sign(secret);

  cookies().set('session', token, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'lax',
    maxAge: SESSION_DURATION / 1000,
    path: '/',
  });

  return token;
}

export async function validateSession(request: Request): Promise<Session | null> {
  const cookieHeader = request.headers.get('cookie');
  if (!cookieHeader) return null;

  const cookies = cookieHeader.split(';').map(c => c.trim());
  const sessionCookie = cookies.find(c => c.startsWith('session='));
  if (!sessionCookie) return null;

  const token = sessionCookie.split('=')[1];

  try {
    const { payload } = await jwtVerify(token, secret);
    const userId = payload.userId as string;

    // In a real app, you'd fetch the user from the database here
    // For now, we'll create a mock user
    const user: User = {
      id: userId,
      githubId: 0,
      username: 'user',
      name: null,
      email: null,
      avatarUrl: null,
      bio: null,
      location: null,
      company: null,
      blog: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    return {
      userId,
      user,
      expiresAt: new Date(Date.now() + SESSION_DURATION),
    };
  } catch (error) {
    return null;
  }
}

export async function getSession(request?: NextRequest): Promise<Session | null> {
  const cookieStore = cookies();
  const token = cookieStore.get('session')?.value;

  if (!token) {
    return null;
  }

  try {
    const { payload } = await jwtVerify(token, secret);
    const userId = payload.userId as string;

    // In a real app, you'd fetch the user from the database here
    const user: User = {
      id: userId,
      githubId: 0,
      username: 'user',
      name: null,
      email: null,
      avatarUrl: null,
      bio: null,
      location: null,
      company: null,
      blog: null,
      createdAt: new Date(),
      updatedAt: new Date(),
    };

    return {
      userId,
      user,
      expiresAt: new Date(Date.now() + SESSION_DURATION),
    };
  } catch (error) {
    return null;
  }
}

export function deleteSession() {
  cookies().delete('session');
}
```

`dahao_0/src/lib/auth/types.ts`:

```ts
export interface User {
  id: string;
  githubId: number;
  username: string;
  name: string | null;
  email: string | null;
  avatarUrl: string | null;
  bio: string | null;
  location: string | null;
  company: string | null;
  blog: string | null;
  createdAt: Date;
  updatedAt: Date;
}

export interface Session {
  userId: string;
  user: User;
  expiresAt: Date;
}

export interface GitHubUser {
  id: number;
  login: string;
  name: string | null;
  email: string | null;
  avatar_url: string | null;
  bio: string | null;
  location: string | null;
  company: string | null;
  blog: string | null;
}

export interface AuthState {
  user: User | null;
  isLoading: boolean;
  error: string | null;
}
```

`dahao_0/src/lib/git/GitOperationsManager.ts`:

```ts
import simpleGit, { SimpleGit, LogResult, DiffResult } from 'simple-git';
import { GitCommit, GitDiff } from '@/types';

export interface IGitOperationsManager {
  init(repoPath: string): Promise<void>;
  getHistory(filePath: string, limit?: number): Promise<GitCommit[]>;
  getDiff(commitHash: string, filePath: string): Promise<GitDiff[]>;
  getFileAtCommit(commitHash: string, filePath: string): Promise<string>;
  getCurrentBranch(): Promise<string>;
  getBranches(): Promise<string[]>;
  checkout(branch: string): Promise<void>;
}

export class GitOperationsManager implements IGitOperationsManager {
  private git: SimpleGit;
  private repoPath: string = '';

  constructor() {
    this.git = simpleGit();
  }

  async init(repoPath: string): Promise<void> {
    this.repoPath = repoPath;
    this.git = simpleGit(repoPath);
    
    // Verify it's a git repository
    const isRepo = await this.git.checkIsRepo();
    if (!isRepo) {
      throw new Error('Not a git repository');
    }
  }

  async getHistory(filePath: string, limit: number = 50): Promise<GitCommit[]> {
    const log: LogResult = await this.git.log({
      file: filePath,
      n: limit,
      format: {
        hash: '%H',
        author: '%an',
        date: '%ai',
        message: '%s'
      }
    });

    return log.all.map(commit => ({
      hash: commit.hash,
      author: commit.author || '',
      date: commit.date || '',
      message: commit.message || ''
    }));
  }

  async getDiff(commitHash: string, filePath: string): Promise<GitDiff[]> {
    const diffSummary = await this.git.diffSummary([
      `${commitHash}^`,
      commitHash,
      '--',
      filePath
    ]);

    const diffs: GitDiff[] = [];
    
    for (const file of diffSummary.files) {
      const patch = await this.git.diff([
        `${commitHash}^`,
        commitHash,
        '--',
        file.file
      ]);

      diffs.push({
        file: file.file,
        additions: file.insertions,
        deletions: file.deletions,
        patch
      });
    }

    return diffs;
  }

  async getFileAtCommit(commitHash: string, filePath: string): Promise<string> {
    try {
      const content = await this.git.show([`${commitHash}:${filePath}`]);
      return content;
    } catch (error) {
      throw new Error(`Failed to get file content at commit ${commitHash}: ${error}`);
    }
  }

  async getCurrentBranch(): Promise<string> {
    const branch = await this.git.revparse(['--abbrev-ref', 'HEAD']);
    return branch.trim();
  }

  async getBranches(): Promise<string[]> {
    const branchSummary = await this.git.branch();
    return Object.keys(branchSummary.branches);
  }

  async checkout(branch: string): Promise<void> {
    await this.git.checkout(branch);
  }
}
```

`dahao_0/src/lib/git/examples.ts`:

```ts
import { GitOperationsManager } from './operations';
import { ProviderConfig } from './providers';
import { getEnvConfig, validateEnvConfig, getProviderToken } from '../../config/env';

// Example usage of GitOperationsManager
async function exampleUsage() {
  // Load environment configuration
  const envConfig = getEnvConfig();
  validateEnvConfig(envConfig);

  // Create provider configuration
  const providerConfig: ProviderConfig = {
    type: envConfig.GIT_PROVIDER || 'github',
    token: getProviderToken(envConfig),
    baseUrl: envConfig.GIT_BASE_URL,
  };

  // Initialize GitOperationsManager
  const gitOps = new GitOperationsManager(providerConfig, envConfig.GIT_OWNER!);

  try {
    // Example 1: Create a new repository
    console.log('Creating new repository...');
    const newRepo = await gitOps.createRepository({
      name: 'test-repo',
      description: 'A test repository created via API',
      private: false,
      autoInit: true,
    });
    console.log('Repository created:', newRepo.fullName);

    // Example 2: Create a new branch
    console.log('\nCreating new branch...');
    const newBranch = await gitOps.createBranch('test-repo', 'feature/new-feature', 'main');
    console.log('Branch created:', newBranch.name);

    // Example 3: Create a new file
    console.log('\nCreating new file...');
    const fileCommit = await gitOps.writeFile(
      'test-repo',
      'src/hello.ts',
      'console.log("Hello, World!");',
      {
        message: 'Add hello.ts file',
        branch: 'feature/new-feature',
      }
    );
    console.log('File created with commit:', fileCommit.commit.sha);

    // Example 4: Update the file
    console.log('\nUpdating file...');
    const updateCommit = await gitOps.updateFile(
      'test-repo',
      'src/hello.ts',
      'console.log("Hello, Updated World!");',
      'Update hello.ts message',
      'feature/new-feature'
    );
    console.log('File updated with commit:', updateCommit.commit.sha);

    // Example 5: Read file content
    console.log('\nReading file content...');
    const content = await gitOps.readFileContent('test-repo', 'src/hello.ts', 'feature/new-feature');
    console.log('File content:', content);

    // Example 6: Create multiple files and commit
    console.log('\nCreating multiple files...');
    const commits = await gitOps.commitAndPush(
      'test-repo',
      [
        { path: 'src/index.ts', content: 'export * from "./hello";' },
        { path: 'README.md', content: '# Test Repository\n\nThis is a test repository.' },
      ],
      'Add index.ts and README.md',
      'feature/new-feature'
    );
    console.log('Created files with commits:', commits.map(c => c.sha));

    // Example 7: List branches
    console.log('\nListing branches...');
    const branches = await gitOps.listBranches('test-repo');
    console.log('Branches:', branches.map(b => b.name));

    // Example 8: Create a pull request
    console.log('\nCreating pull request...');
    const pullRequest = await gitOps.createPullRequestFromBranch(
      'test-repo',
      'feature/new-feature',
      'Add new feature',
      'This PR adds a new feature with hello.ts file and documentation.',
      'main'
    );
    console.log('Pull request created:', pullRequest.number, pullRequest.title);

    // Example 9: List commits
    console.log('\nListing commits...');
    const recentCommits = await gitOps.listCommits('test-repo', {
      perPage: 5,
    });
    console.log('Recent commits:');
    recentCommits.forEach(commit => {
      console.log(`  - ${commit.sha.substring(0, 7)}: ${commit.message}`);
    });

    // Example 10: Merge pull request
    console.log('\nMerging pull request...');
    await gitOps.mergePullRequest('test-repo', pullRequest.number, {
      mergeMethod: 'squash',
    });
    console.log('Pull request merged!');

  } catch (error) {
    console.error('Error:', error);
  }
}

// Example: Working with existing repository
async function workWithExistingRepo() {
  const envConfig = getEnvConfig();
  validateEnvConfig(envConfig);

  const providerConfig: ProviderConfig = {
    type: envConfig.GIT_PROVIDER || 'github',
    token: getProviderToken(envConfig),
  };

  const gitOps = new GitOperationsManager(providerConfig, envConfig.GIT_OWNER!);

  try {
    // Get repository information
    const repo = await gitOps.getRepository('existing-repo');
    console.log('Repository:', repo.fullName);
    console.log('Default branch:', repo.defaultBranch);
    console.log('Description:', repo.description);

    // List open pull requests
    const openPRs = await gitOps.listPullRequests('existing-repo', {
      state: 'open',
    });
    console.log('\nOpen Pull Requests:');
    openPRs.forEach(pr => {
      console.log(`  - #${pr.number}: ${pr.title} (by ${pr.user.login})`);
    });

  } catch (error) {
    console.error('Error:', error);
  }
}

// Example: Fork and contribute workflow
async function forkAndContribute() {
  const envConfig = getEnvConfig();
  validateEnvConfig(envConfig);

  const providerConfig: ProviderConfig = {
    type: envConfig.GIT_PROVIDER || 'github',
    token: getProviderToken(envConfig),
  };

  const gitOps = new GitOperationsManager(providerConfig, envConfig.GIT_OWNER!);

  try {
    // Fork a repository
    console.log('Forking repository...');
    const forkedRepo = await gitOps.forkRepository('original-owner', 'awesome-project');
    console.log('Forked to:', forkedRepo.fullName);

    // Create a feature branch in the fork
    const branch = await gitOps.createBranch(forkedRepo.name, 'fix/typo', 'main');
    console.log('Created branch:', branch.name);

    // Make changes
    await gitOps.updateFile(
      forkedRepo.name,
      'README.md',
      '# Awesome Project\n\nFixed typo in README.',
      'Fix typo in README',
      'fix/typo'
    );

    // Create pull request
    const pr = await gitOps.createPullRequest(forkedRepo.name, {
      title: 'Fix typo in README',
      body: 'This PR fixes a small typo in the README file.',
      head: `${envConfig.GIT_OWNER}:fix/typo`,
      base: 'main',
    });
    console.log('Pull request created:', pr.url);

  } catch (error) {
    console.error('Error:', error);
  }
}

// Export example functions for testing
export {
  exampleUsage,
  workWithExistingRepo,
  forkAndContribute,
};

// Run examples if this file is executed directly
if (require.main === module) {
  console.log('Running Git Operations Examples...\n');
  
  // Uncomment the example you want to run:
  // exampleUsage();
  // workWithExistingRepo();
  // forkAndContribute();
}
```

`dahao_0/src/lib/git/index.ts`:

```ts
// Main exports for the git module
export { GitOperationsManager } from './operations';
export { GitProviderFactory } from './providers';
export type {
  ProviderConfig,
  ProviderType,
  GitProvider,
  Repository,
  Branch,
  FileContent,
  FileCommit,
  Commit,
  PullRequest,
  CreateRepositoryOptions,
  WriteFileOptions,
  DeleteFileOptions,
  CreateCommitOptions,
  ListCommitsOptions,
  CreatePullRequestOptions,
  UpdatePullRequestOptions,
  ListPullRequestsOptions,
  MergePullRequestOptions,
} from './providers';
```

`dahao_0/src/lib/git/operations.ts`:

```ts
import {
  GitProvider,
  Repository,
  Branch,
  FileContent,
  FileCommit,
  Commit,
  PullRequest,
  CreateRepositoryOptions,
  WriteFileOptions,
  DeleteFileOptions,
  CreateCommitOptions,
  ListCommitsOptions,
  CreatePullRequestOptions,
  UpdatePullRequestOptions,
  ListPullRequestsOptions,
  MergePullRequestOptions,
} from './providers';
import { GitProviderFactory, ProviderConfig } from './providers';

export class GitOperationsManager {
  private provider: GitProvider;
  private owner: string;

  constructor(config: ProviderConfig, owner: string) {
    this.provider = GitProviderFactory.create(config);
    this.owner = owner;
  }

  // Repository Management
  async createRepository(options: CreateRepositoryOptions): Promise<Repository> {
    return this.provider.createRepository(options);
  }

  async forkRepository(owner: string, repo: string): Promise<Repository> {
    return this.provider.forkRepository(owner, repo);
  }

  async deleteRepository(repo: string): Promise<void> {
    return this.provider.deleteRepository(this.owner, repo);
  }

  async getRepository(repo: string): Promise<Repository> {
    return this.provider.getRepository(this.owner, repo);
  }

  // Branch Operations
  async createBranch(repo: string, branch: string, from: string = 'main'): Promise<Branch> {
    return this.provider.createBranch(this.owner, repo, branch, from);
  }

  async deleteBranch(repo: string, branch: string): Promise<void> {
    return this.provider.deleteBranch(this.owner, repo, branch);
  }

  async listBranches(repo: string): Promise<Branch[]> {
    return this.provider.listBranches(this.owner, repo);
  }

  async getBranch(repo: string, branch: string): Promise<Branch> {
    return this.provider.getBranch(this.owner, repo, branch);
  }

  // File Operations
  async readFile(repo: string, path: string, ref?: string): Promise<FileContent> {
    return this.provider.readFile(this.owner, repo, path, ref);
  }

  async writeFile(repo: string, path: string, content: string, options: WriteFileOptions): Promise<FileCommit> {
    return this.provider.writeFile(this.owner, repo, path, content, options);
  }

  async deleteFile(repo: string, path: string, options: DeleteFileOptions): Promise<FileCommit> {
    return this.provider.deleteFile(this.owner, repo, path, options);
  }

  async updateFile(repo: string, path: string, content: string, message: string, branch?: string): Promise<FileCommit> {
    // First, get the current file to get its SHA
    const currentFile = await this.readFile(repo, path, branch);
    
    return this.writeFile(repo, path, content, {
      message,
      branch,
      sha: currentFile.sha,
    });
  }

  // Commit Operations
  async createCommit(repo: string, options: CreateCommitOptions): Promise<Commit> {
    return this.provider.createCommit(this.owner, repo, options);
  }

  async getCommit(repo: string, sha: string): Promise<Commit> {
    return this.provider.getCommit(this.owner, repo, sha);
  }

  async listCommits(repo: string, options?: ListCommitsOptions): Promise<Commit[]> {
    return this.provider.listCommits(this.owner, repo, options);
  }

  // Pull Request Operations
  async createPullRequest(repo: string, options: CreatePullRequestOptions): Promise<PullRequest> {
    return this.provider.createPullRequest(this.owner, repo, options);
  }

  async updatePullRequest(repo: string, number: number, options: UpdatePullRequestOptions): Promise<PullRequest> {
    return this.provider.updatePullRequest(this.owner, repo, number, options);
  }

  async getPullRequest(repo: string, number: number): Promise<PullRequest> {
    return this.provider.getPullRequest(this.owner, repo, number);
  }

  async listPullRequests(repo: string, options?: ListPullRequestsOptions): Promise<PullRequest[]> {
    return this.provider.listPullRequests(this.owner, repo, options);
  }

  async mergePullRequest(repo: string, number: number, options?: MergePullRequestOptions): Promise<void> {
    return this.provider.mergePullRequest(this.owner, repo, number, options);
  }

  // Helper Methods
  async createAndCheckoutBranch(repo: string, branch: string, from: string = 'main'): Promise<Branch> {
    const newBranch = await this.createBranch(repo, branch, from);
    return newBranch;
  }

  async commitAndPush(
    repo: string,
    files: Array<{ path: string; content: string }>,
    message: string,
    branch?: string
  ): Promise<Commit[]> {
    const commits: Commit[] = [];

    for (const file of files) {
      try {
        // Try to update existing file
        const fileCommit = await this.updateFile(repo, file.path, file.content, message, branch);
        commits.push(fileCommit.commit);
      } catch (error) {
        // If file doesn't exist, create it
        const fileCommit = await this.writeFile(repo, file.path, file.content, {
          message,
          branch,
        });
        commits.push(fileCommit.commit);
      }
    }

    return commits;
  }

  async createPullRequestFromBranch(
    repo: string,
    branch: string,
    title: string,
    body?: string,
    baseBranch: string = 'main'
  ): Promise<PullRequest> {
    return this.createPullRequest(repo, {
      title,
      body,
      head: branch,
      base: baseBranch,
    });
  }

  // Utility to get file content as string (decoded from base64)
  async readFileContent(repo: string, path: string, ref?: string): Promise<string> {
    const file = await this.readFile(repo, path, ref);
    
    if (file.encoding === 'base64') {
      return Buffer.from(file.content, 'base64').toString('utf-8');
    }
    
    return file.content;
  }

  // Get the current provider name
  getProviderName(): string {
    return this.provider.name;
  }
}
```

`dahao_0/src/lib/git/providers/github.ts`:

```ts
import { Octokit } from '@octokit/rest';
import {
  GitProvider,
  Repository,
  Branch,
  FileContent,
  FileCommit,
  Commit,
  PullRequest,
  CreateRepositoryOptions,
  WriteFileOptions,
  DeleteFileOptions,
  CreateCommitOptions,
  ListCommitsOptions,
  CreatePullRequestOptions,
  UpdatePullRequestOptions,
  ListPullRequestsOptions,
  MergePullRequestOptions,
} from './types';

export class GitHubProvider implements GitProvider {
  name = 'github';
  private octokit: Octokit;

  constructor(token: string) {
    this.octokit = new Octokit({
      auth: token,
    });
  }

  async createRepository(options: CreateRepositoryOptions): Promise<Repository> {
    const { data } = await this.octokit.repos.createForAuthenticatedUser({
      name: options.name,
      description: options.description,
      private: options.private,
      auto_init: options.autoInit,
      gitignore_template: options.gitignoreTemplate,
      license_template: options.license,
    });

    return this.mapRepository(data);
  }

  async forkRepository(owner: string, repo: string): Promise<Repository> {
    const { data } = await this.octokit.repos.createFork({
      owner,
      repo,
    });

    return this.mapRepository(data);
  }

  async deleteRepository(owner: string, repo: string): Promise<void> {
    await this.octokit.repos.delete({
      owner,
      repo,
    });
  }

  async getRepository(owner: string, repo: string): Promise<Repository> {
    const { data } = await this.octokit.repos.get({
      owner,
      repo,
    });

    return this.mapRepository(data);
  }

  async createBranch(owner: string, repo: string, branch: string, from: string): Promise<Branch> {
    // Get the commit SHA for the source branch
    const { data: refData } = await this.octokit.git.getRef({
      owner,
      repo,
      ref: `heads/${from}`,
    });

    // Create the new branch
    const { data } = await this.octokit.git.createRef({
      owner,
      repo,
      ref: `refs/heads/${branch}`,
      sha: refData.object.sha,
    });

    return {
      name: branch,
      commit: {
        sha: data.object.sha,
        url: data.object.url,
      },
      protected: false,
    };
  }

  async deleteBranch(owner: string, repo: string, branch: string): Promise<void> {
    await this.octokit.git.deleteRef({
      owner,
      repo,
      ref: `heads/${branch}`,
    });
  }

  async listBranches(owner: string, repo: string): Promise<Branch[]> {
    const { data } = await this.octokit.repos.listBranches({
      owner,
      repo,
      per_page: 100,
    });

    return data.map(branch => ({
      name: branch.name,
      commit: {
        sha: branch.commit.sha,
        url: branch.commit.url,
      },
      protected: branch.protected,
    }));
  }

  async getBranch(owner: string, repo: string, branch: string): Promise<Branch> {
    const { data } = await this.octokit.repos.getBranch({
      owner,
      repo,
      branch,
    });

    return {
      name: data.name,
      commit: {
        sha: data.commit.sha,
        url: data.commit.url,
      },
      protected: data.protected,
    };
  }

  async readFile(owner: string, repo: string, path: string, ref?: string): Promise<FileContent> {
    const { data } = await this.octokit.repos.getContent({
      owner,
      repo,
      path,
      ref,
    });

    if (Array.isArray(data)) {
      throw new Error('Path is a directory, not a file');
    }

    if ('type' in data && data.type !== 'file') {
      throw new Error('Path is not a file');
    }

    return {
      name: data.name,
      path: data.path,
      sha: data.sha,
      size: data.size,
      content: data.content || '',
      encoding: data.encoding || 'base64',
    };
  }

  async writeFile(owner: string, repo: string, path: string, content: string, options: WriteFileOptions): Promise<FileCommit> {
    const { data } = await this.octokit.repos.createOrUpdateFileContents({
      owner,
      repo,
      path,
      message: options.message,
      content: Buffer.from(content).toString('base64'),
      branch: options.branch,
      committer: options.committer,
      sha: options.sha,
    });

    return {
      content: {
        name: data.content!.name,
        path: data.content!.path,
        sha: data.content!.sha,
        size: data.content!.size,
        content: Buffer.from(content).toString('base64'),
        encoding: 'base64',
      },
      commit: this.mapCommit(data.commit),
    };
  }

  async deleteFile(owner: string, repo: string, path: string, options: DeleteFileOptions): Promise<FileCommit> {
    const { data } = await this.octokit.repos.deleteFile({
      owner,
      repo,
      path,
      message: options.message,
      sha: options.sha,
      branch: options.branch,
      committer: options.committer,
    });

    return {
      content: {
        name: path.split('/').pop() || '',
        path: path,
        sha: '',
        size: 0,
        content: '',
        encoding: '',
      },
      commit: this.mapCommit(data.commit),
    };
  }

  async createCommit(owner: string, repo: string, options: CreateCommitOptions): Promise<Commit> {
    const { data } = await this.octokit.git.createCommit({
      owner,
      repo,
      message: options.message,
      tree: options.tree,
      parents: options.parents,
      author: options.author,
      committer: options.committer,
    });

    return this.mapGitCommit(data);
  }

  async getCommit(owner: string, repo: string, sha: string): Promise<Commit> {
    const { data } = await this.octokit.git.getCommit({
      owner,
      repo,
      commit_sha: sha,
    });

    return this.mapGitCommit(data);
  }

  async listCommits(owner: string, repo: string, options?: ListCommitsOptions): Promise<Commit[]> {
    const { data } = await this.octokit.repos.listCommits({
      owner,
      repo,
      sha: options?.sha,
      path: options?.path,
      author: options?.author,
      since: options?.since?.toISOString(),
      until: options?.until?.toISOString(),
      per_page: options?.perPage || 100,
      page: options?.page,
    });

    return data.map(commit => this.mapCommit(commit.commit));
  }

  async createPullRequest(owner: string, repo: string, options: CreatePullRequestOptions): Promise<PullRequest> {
    const { data } = await this.octokit.pulls.create({
      owner,
      repo,
      title: options.title,
      body: options.body,
      head: options.head,
      base: options.base,
      draft: options.draft,
    });

    return this.mapPullRequest(data);
  }

  async updatePullRequest(owner: string, repo: string, number: number, options: UpdatePullRequestOptions): Promise<PullRequest> {
    const { data } = await this.octokit.pulls.update({
      owner,
      repo,
      pull_number: number,
      title: options.title,
      body: options.body,
      state: options.state,
      base: options.base,
    });

    return this.mapPullRequest(data);
  }

  async getPullRequest(owner: string, repo: string, number: number): Promise<PullRequest> {
    const { data } = await this.octokit.pulls.get({
      owner,
      repo,
      pull_number: number,
    });

    return this.mapPullRequest(data);
  }

  async listPullRequests(owner: string, repo: string, options?: ListPullRequestsOptions): Promise<PullRequest[]> {
    const { data } = await this.octokit.pulls.list({
      owner,
      repo,
      state: options?.state,
      head: options?.head,
      base: options?.base,
      sort: options?.sort,
      direction: options?.direction,
      per_page: options?.perPage || 100,
      page: options?.page,
    });

    return data.map(pr => this.mapPullRequest(pr));
  }

  async mergePullRequest(owner: string, repo: string, number: number, options?: MergePullRequestOptions): Promise<void> {
    await this.octokit.pulls.merge({
      owner,
      repo,
      pull_number: number,
      commit_title: options?.commitTitle,
      commit_message: options?.commitMessage,
      sha: options?.sha,
      merge_method: options?.mergeMethod,
    });
  }

  private mapRepository(data: any): Repository {
    return {
      id: data.id.toString(),
      name: data.name,
      fullName: data.full_name,
      owner: data.owner.login,
      description: data.description,
      private: data.private,
      defaultBranch: data.default_branch,
      url: data.html_url,
      cloneUrl: data.clone_url,
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
    };
  }

  private mapCommit(data: any): Commit {
    return {
      sha: data.sha || data.tree.sha,
      message: data.message,
      author: {
        name: data.author.name,
        email: data.author.email,
        date: new Date(data.author.date),
      },
      committer: {
        name: data.committer.name,
        email: data.committer.email,
        date: new Date(data.committer.date),
      },
      url: data.url,
      parents: data.parents || [],
    };
  }

  private mapGitCommit(data: any): Commit {
    return {
      sha: data.sha,
      message: data.message,
      author: {
        name: data.author.name,
        email: data.author.email,
        date: new Date(data.author.date),
      },
      committer: {
        name: data.committer.name,
        email: data.committer.email,
        date: new Date(data.committer.date),
      },
      url: data.url,
      parents: data.parents.map((p: any) => ({ sha: p.sha, url: p.url })),
    };
  }

  private mapPullRequest(data: any): PullRequest {
    return {
      id: data.id,
      number: data.number,
      title: data.title,
      body: data.body,
      state: data.state,
      head: {
        ref: data.head.ref,
        sha: data.head.sha,
      },
      base: {
        ref: data.base.ref,
        sha: data.base.sha,
      },
      user: {
        login: data.user.login,
      },
      createdAt: new Date(data.created_at),
      updatedAt: new Date(data.updated_at),
      mergedAt: data.merged_at ? new Date(data.merged_at) : undefined,
      url: data.html_url,
    };
  }
}
```

`dahao_0/src/lib/git/providers/index.ts`:

```ts
import { GitProvider } from './types';
import { GitHubProvider } from './github';

export type ProviderType = 'github' | 'gitlab' | 'gitea';

export interface ProviderConfig {
  type: ProviderType;
  token: string;
  baseUrl?: string; // For self-hosted instances
}

export class GitProviderFactory {
  static create(config: ProviderConfig): GitProvider {
    switch (config.type) {
      case 'github':
        return new GitHubProvider(config.token);
      case 'gitlab':
        throw new Error('GitLab provider not implemented yet');
      case 'gitea':
        throw new Error('Gitea provider not implemented yet');
      default:
        throw new Error(`Unknown provider type: ${config.type}`);
    }
  }
}

export * from './types';
export { GitHubProvider } from './github';
```

`dahao_0/src/lib/git/providers/types.ts`:

```ts
export interface GitProvider {
  name: string;
  
  // Repository operations
  createRepository(options: CreateRepositoryOptions): Promise<Repository>;
  forkRepository(owner: string, repo: string): Promise<Repository>;
  deleteRepository(owner: string, repo: string): Promise<void>;
  getRepository(owner: string, repo: string): Promise<Repository>;
  
  // Branch operations
  createBranch(owner: string, repo: string, branch: string, from: string): Promise<Branch>;
  deleteBranch(owner: string, repo: string, branch: string): Promise<void>;
  listBranches(owner: string, repo: string): Promise<Branch[]>;
  getBranch(owner: string, repo: string, branch: string): Promise<Branch>;
  
  // File operations
  readFile(owner: string, repo: string, path: string, ref?: string): Promise<FileContent>;
  writeFile(owner: string, repo: string, path: string, content: string, options: WriteFileOptions): Promise<FileCommit>;
  deleteFile(owner: string, repo: string, path: string, options: DeleteFileOptions): Promise<FileCommit>;
  
  // Commit operations
  createCommit(owner: string, repo: string, options: CreateCommitOptions): Promise<Commit>;
  getCommit(owner: string, repo: string, sha: string): Promise<Commit>;
  listCommits(owner: string, repo: string, options?: ListCommitsOptions): Promise<Commit[]>;
  
  // Pull request operations
  createPullRequest(owner: string, repo: string, options: CreatePullRequestOptions): Promise<PullRequest>;
  updatePullRequest(owner: string, repo: string, number: number, options: UpdatePullRequestOptions): Promise<PullRequest>;
  getPullRequest(owner: string, repo: string, number: number): Promise<PullRequest>;
  listPullRequests(owner: string, repo: string, options?: ListPullRequestsOptions): Promise<PullRequest[]>;
  mergePullRequest(owner: string, repo: string, number: number, options?: MergePullRequestOptions): Promise<void>;
}

export interface Repository {
  id: string;
  name: string;
  fullName: string;
  owner: string;
  description?: string;
  private: boolean;
  defaultBranch: string;
  url: string;
  cloneUrl: string;
  createdAt: Date;
  updatedAt: Date;
}

export interface Branch {
  name: string;
  commit: {
    sha: string;
    url: string;
  };
  protected: boolean;
}

export interface FileContent {
  name: string;
  path: string;
  sha: string;
  size: number;
  content: string;
  encoding: string;
}

export interface FileCommit {
  content: FileContent;
  commit: Commit;
}

export interface Commit {
  sha: string;
  message: string;
  author: {
    name: string;
    email: string;
    date: Date;
  };
  committer: {
    name: string;
    email: string;
    date: Date;
  };
  url: string;
  parents: Array<{ sha: string; url: string }>;
}

export interface PullRequest {
  id: number;
  number: number;
  title: string;
  body?: string;
  state: 'open' | 'closed';
  head: {
    ref: string;
    sha: string;
  };
  base: {
    ref: string;
    sha: string;
  };
  user: {
    login: string;
  };
  createdAt: Date;
  updatedAt: Date;
  mergedAt?: Date;
  url: string;
}

export interface CreateRepositoryOptions {
  name: string;
  description?: string;
  private?: boolean;
  autoInit?: boolean;
  gitignoreTemplate?: string;
  license?: string;
}

export interface WriteFileOptions {
  message: string;
  branch?: string;
  committer?: {
    name: string;
    email: string;
  };
  sha?: string; // Required for updates
}

export interface DeleteFileOptions {
  message: string;
  branch?: string;
  committer?: {
    name: string;
    email: string;
  };
  sha: string;
}

export interface CreateCommitOptions {
  message: string;
  tree: string;
  parents: string[];
  author?: {
    name: string;
    email: string;
    date?: string;
  };
  committer?: {
    name: string;
    email: string;
    date?: string;
  };
}

export interface ListCommitsOptions {
  sha?: string;
  path?: string;
  author?: string;
  since?: Date;
  until?: Date;
  perPage?: number;
  page?: number;
}

export interface CreatePullRequestOptions {
  title: string;
  body?: string;
  head: string;
  base: string;
  draft?: boolean;
}

export interface UpdatePullRequestOptions {
  title?: string;
  body?: string;
  state?: 'open' | 'closed';
  base?: string;
}

export interface ListPullRequestsOptions {
  state?: 'open' | 'closed' | 'all';
  head?: string;
  base?: string;
  sort?: 'created' | 'updated' | 'popularity' | 'long-running';
  direction?: 'asc' | 'desc';
  perPage?: number;
  page?: number;
}

export interface MergePullRequestOptions {
  commitTitle?: string;
  commitMessage?: string;
  sha?: string;
  mergeMethod?: 'merge' | 'squash' | 'rebase';
}
```

`dahao_0/src/lib/validation/SchemaValidator.ts`:

```ts
import Ajv from 'ajv';
import { ValidationResult, ValidationError } from '@/types';

const dahaoSchema = {
  type: 'object',
  properties: {
    version: { type: 'string', pattern: '^\\d+\\.\\d+\\.\\d+$' },
    metadata: {
      type: 'object',
      properties: {
        created: { type: 'string', format: 'date-time' },
        lastModified: { type: 'string', format: 'date-time' },
        author: { type: 'string' }
      },
      required: ['created', 'lastModified', 'author']
    },
    entries: {
      type: 'array',
      items: {
        type: 'object',
        properties: {
          id: { type: 'string' },
          timestamp: { type: 'string', format: 'date-time' },
          title: { type: 'string' },
          description: { type: 'string' },
          participants: {
            type: 'array',
            items: { type: 'string' }
          },
          tags: {
            type: 'array',
            items: { type: 'string' }
          },
          relatedEntries: {
            type: 'array',
            items: { type: 'string' }
          },
          customData: { type: 'object' }
        },
        required: ['id', 'timestamp', 'title', 'description', 'participants', 'tags']
      }
    }
  },
  required: ['version', 'metadata', 'entries']
};

export class SchemaValidator {
  private ajv: Ajv;
  private validate: any;

  constructor() {
    this.ajv = new Ajv({ allErrors: true });
    this.validate = this.ajv.compile(dahaoSchema);
  }

  validateDAHAOFile(data: any): ValidationResult {
    const valid = this.validate(data);
    
    if (valid) {
      return { valid: true };
    }
    
    const errors: ValidationError[] = this.validate.errors.map((error: any) => ({
      path: error.instancePath || '/',
      message: error.message || 'Unknown error',
      code: error.keyword
    }));
    
    return { valid: false, errors };
  }

  validateEntry(entry: any): ValidationResult {
    const entrySchema = dahaoSchema.properties.entries.items;
    const validateEntry = this.ajv.compile(entrySchema);
    const valid = validateEntry(entry);
    
    if (valid) {
      return { valid: true };
    }
    
    const errors: ValidationError[] = validateEntry.errors.map((error: any) => ({
      path: error.instancePath || '/',
      message: error.message || 'Unknown error',
      code: error.keyword
    }));
    
    return { valid: false, errors };
  }
}
```

`dahao_0/src/lib/yaml/YamlProcessor.ts`:

```ts
import yaml from 'js-yaml';
import { DAHAOFile, DAHAOEntry } from '@/types';

export class YamlProcessor {
  static parse(content: string): DAHAOFile {
    try {
      const data = yaml.load(content) as DAHAOFile;
      return data;
    } catch (error) {
      throw new Error(`Failed to parse YAML: ${error}`);
    }
  }

  static stringify(data: DAHAOFile): string {
    try {
      return yaml.dump(data, {
        indent: 2,
        lineWidth: -1,
        noRefs: true,
        sortKeys: false,
      });
    } catch (error) {
      throw new Error(`Failed to stringify YAML: ${error}`);
    }
  }

  static validateStructure(data: any): boolean {
    if (!data || typeof data !== 'object') return false;
    if (!data.version || typeof data.version !== 'string') return false;
    if (!data.metadata || typeof data.metadata !== 'object') return false;
    if (!Array.isArray(data.entries)) return false;
    
    return true;
  }

  static mergeEntries(existing: DAHAOEntry[], incoming: DAHAOEntry[]): DAHAOEntry[] {
    const entryMap = new Map<string, DAHAOEntry>();
    
    // Add existing entries
    existing.forEach(entry => {
      entryMap.set(entry.id, entry);
    });
    
    // Merge or add incoming entries
    incoming.forEach(entry => {
      if (entryMap.has(entry.id)) {
        // Merge logic - newer timestamp wins
        const existingEntry = entryMap.get(entry.id)!;
        if (new Date(entry.timestamp) > new Date(existingEntry.timestamp)) {
          entryMap.set(entry.id, entry);
        }
      } else {
        entryMap.set(entry.id, entry);
      }
    });
    
    // Sort by timestamp
    return Array.from(entryMap.values()).sort((a, b) => 
      new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );
  }
}
```

`dahao_0/src/store/index.ts`:

```ts
import { create } from 'zustand';
import { devtools, persist } from 'zustand/middleware';
import { immer } from 'zustand/middleware/immer';
import { createGitSlice, GitSlice } from './slices/git';
import { createDocumentSlice, DocumentSlice } from './slices/document';
import { createGovernanceSlice, GovernanceSlice } from './slices/governance';
import { createAuthSlice, AuthSlice } from './slices/auth';

export type StoreState = GitSlice & DocumentSlice & GovernanceSlice & AuthSlice;

export const useStore = create<StoreState>()(
  devtools(
    persist(
      immer((...a) => ({
        ...createGitSlice(...a),
        ...createDocumentSlice(...a),
        ...createGovernanceSlice(...a),
        ...createAuthSlice(...a),
      })),
      {
        name: 'dahao-storage',
        partialize: (state) => ({
          // Only persist specific parts of the state
          user: state.user,
          isAuthenticated: state.isAuthenticated,
        }),
      }
    )
  )
);

export default useStore;
```

`dahao_0/src/store/slices/auth.ts`:

```ts
import { StateCreator } from 'zustand';
import { StoreState } from '..';

export interface User {
  id: string;
  username: string;
  email: string;
  avatarUrl: string;
  githubId: string;
  accessToken?: string;
}

export interface AuthSlice {
  // State
  user: User | null;
  isAuthenticated: boolean;
  isLoading: boolean;
  error: string | null;

  // Actions
  login: () => Promise<void>;
  logout: () => Promise<void>;
  checkAuth: () => Promise<void>;
  setUser: (user: User | null) => void;
}

export const createAuthSlice: StateCreator<
  StoreState,
  [],
  [],
  AuthSlice
> = (set) => ({
  // Initial state
  user: null,
  isAuthenticated: false,
  isLoading: false,
  error: null,

  // Actions
  login: async () => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      // Redirect to GitHub OAuth
      window.location.href = '/api/auth/github';
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  logout: async () => {
    try {
      const response = await fetch('/api/auth/logout', {
        method: 'POST',
      });
      
      if (!response.ok) throw new Error('Failed to logout');
      
      set((state) => {
        state.user = null;
        state.isAuthenticated = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  checkAuth: async () => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const response = await fetch('/api/auth/me');
      
      if (response.ok) {
        const user = await response.json();
        set((state) => {
          state.user = user;
          state.isAuthenticated = true;
          state.isLoading = false;
        });
      } else {
        set((state) => {
          state.user = null;
          state.isAuthenticated = false;
          state.isLoading = false;
        });
      }
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isAuthenticated = false;
        state.isLoading = false;
      });
    }
  },

  setUser: (user) => set((state) => {
    state.user = user;
    state.isAuthenticated = !!user;
  }),
});
```

`dahao_0/src/store/slices/document.ts`:

```ts
import { StateCreator } from 'zustand';
import { StoreState } from '..';

export interface Document {
  id: string;
  title: string;
  content: string;
  path: string;
  lastModified: string;
  author: string;
  tags: string[];
  type: 'dao' | 'standard' | 'proposal';
}

export interface DocumentSlice {
  // State
  documents: Document[];
  currentDocument: Document | null;
  searchQuery: string;
  isLoading: boolean;
  error: string | null;

  // Actions
  setDocuments: (documents: Document[]) => void;
  setCurrentDocument: (document: Document | null) => void;
  setSearchQuery: (query: string) => void;
  fetchDocuments: (type?: string) => Promise<void>;
  fetchDocument: (id: string) => Promise<void>;
  createDocument: (document: Omit<Document, 'id' | 'lastModified'>) => Promise<void>;
  updateDocument: (id: string, updates: Partial<Document>) => Promise<void>;
  deleteDocument: (id: string) => Promise<void>;
  searchDocuments: (query: string) => Promise<void>;
}

export const createDocumentSlice: StateCreator<
  StoreState,
  [],
  [],
  DocumentSlice
> = (set, get) => ({
  // Initial state
  documents: [],
  currentDocument: null,
  searchQuery: '',
  isLoading: false,
  error: null,

  // Actions
  setDocuments: (documents) => set((state) => {
    state.documents = documents;
  }),

  setCurrentDocument: (document) => set((state) => {
    state.currentDocument = document;
  }),

  setSearchQuery: (query) => set((state) => {
    state.searchQuery = query;
  }),

  fetchDocuments: async (type) => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const url = type ? `/api/documents?type=${type}` : '/api/documents';
      const response = await fetch(url);
      if (!response.ok) throw new Error('Failed to fetch documents');
      
      const documents = await response.json();
      set((state) => {
        state.documents = documents;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  fetchDocument: async (id) => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const response = await fetch(`/api/documents/${id}`);
      if (!response.ok) throw new Error('Failed to fetch document');
      
      const document = await response.json();
      set((state) => {
        state.currentDocument = document;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  createDocument: async (document) => {
    try {
      const response = await fetch('/api/documents', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(document),
      });
      
      if (!response.ok) throw new Error('Failed to create document');
      await get().fetchDocuments();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  updateDocument: async (id, updates) => {
    try {
      const response = await fetch(`/api/documents/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });
      
      if (!response.ok) throw new Error('Failed to update document');
      await get().fetchDocuments();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  deleteDocument: async (id) => {
    try {
      const response = await fetch(`/api/documents/${id}`, {
        method: 'DELETE',
      });
      
      if (!response.ok) throw new Error('Failed to delete document');
      await get().fetchDocuments();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  searchDocuments: async (query) => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
      state.searchQuery = query;
    });

    try {
      const response = await fetch(`/api/documents/search?q=${encodeURIComponent(query)}`);
      if (!response.ok) throw new Error('Failed to search documents');
      
      const documents = await response.json();
      set((state) => {
        state.documents = documents;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },
});
```

`dahao_0/src/store/slices/git.ts`:

```ts
import { StateCreator } from 'zustand';
import { StoreState } from '..';

export interface GitFile {
  path: string;
  content: string;
  sha: string;
  type: 'file' | 'dir';
}

export interface GitCommit {
  sha: string;
  author: string;
  message: string;
  date: string;
}

export interface GitSlice {
  // State
  currentRepo: string | null;
  currentBranch: string;
  files: GitFile[];
  commits: GitCommit[];
  isLoading: boolean;
  error: string | null;

  // Actions
  setCurrentRepo: (repo: string) => void;
  setCurrentBranch: (branch: string) => void;
  fetchFiles: (path?: string) => Promise<void>;
  fetchCommits: () => Promise<void>;
  createFile: (path: string, content: string, message: string) => Promise<void>;
  updateFile: (path: string, content: string, message: string) => Promise<void>;
  deleteFile: (path: string, message: string) => Promise<void>;
  createBranch: (branchName: string) => Promise<void>;
  createPullRequest: (title: string, body: string, base?: string) => Promise<void>;
}

export const createGitSlice: StateCreator<
  StoreState,
  [],
  [],
  GitSlice
> = (set, get) => ({
  // Initial state
  currentRepo: null,
  currentBranch: 'main',
  files: [],
  commits: [],
  isLoading: false,
  error: null,

  // Actions
  setCurrentRepo: (repo) => set((state) => {
    state.currentRepo = repo;
  }),

  setCurrentBranch: (branch) => set((state) => {
    state.currentBranch = branch;
  }),

  fetchFiles: async (path = '') => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const response = await fetch(`/api/git/files?path=${path}`);
      if (!response.ok) throw new Error('Failed to fetch files');
      
      const files = await response.json();
      set((state) => {
        state.files = files;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  fetchCommits: async () => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const response = await fetch('/api/git/commits');
      if (!response.ok) throw new Error('Failed to fetch commits');
      
      const commits = await response.json();
      set((state) => {
        state.commits = commits;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  createFile: async (path, content, message) => {
    try {
      const response = await fetch('/api/git/files', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path, content, message }),
      });
      
      if (!response.ok) throw new Error('Failed to create file');
      await get().fetchFiles();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  updateFile: async (path, content, message) => {
    try {
      const response = await fetch('/api/git/files', {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path, content, message }),
      });
      
      if (!response.ok) throw new Error('Failed to update file');
      await get().fetchFiles();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  deleteFile: async (path, message) => {
    try {
      const response = await fetch('/api/git/files', {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ path, message }),
      });
      
      if (!response.ok) throw new Error('Failed to delete file');
      await get().fetchFiles();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  createBranch: async (branchName) => {
    try {
      const response = await fetch('/api/git/branches', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ branchName }),
      });
      
      if (!response.ok) throw new Error('Failed to create branch');
      set((state) => {
        state.currentBranch = branchName;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  createPullRequest: async (title, body, base = 'main') => {
    try {
      const response = await fetch('/api/git/pull-requests', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ title, body, base, head: get().currentBranch }),
      });
      
      if (!response.ok) throw new Error('Failed to create pull request');
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },
});
```

`dahao_0/src/store/slices/governance.ts`:

```ts
import { StateCreator } from 'zustand';
import { StoreState } from '..';

export interface Proposal {
  id: string;
  title: string;
  description: string;
  author: string;
  status: 'draft' | 'active' | 'approved' | 'rejected' | 'implemented';
  type: 'standard' | 'emergency' | 'constitutional';
  createdAt: string;
  votingEndsAt: string;
  votes: {
    for: number;
    against: number;
    abstain: number;
  };
  quorum: number;
  threshold: number;
}

export interface Vote {
  proposalId: string;
  voter: string;
  choice: 'for' | 'against' | 'abstain';
  timestamp: string;
  reason?: string;
}

export interface GovernanceSlice {
  // State
  proposals: Proposal[];
  currentProposal: Proposal | null;
  userVotes: Record<string, Vote>;
  isLoading: boolean;
  error: string | null;

  // Actions
  fetchProposals: (status?: string) => Promise<void>;
  fetchProposal: (id: string) => Promise<void>;
  createProposal: (proposal: Omit<Proposal, 'id' | 'createdAt' | 'votes'>) => Promise<void>;
  updateProposal: (id: string, updates: Partial<Proposal>) => Promise<void>;
  submitVote: (proposalId: string, choice: Vote['choice'], reason?: string) => Promise<void>;
  executeProposal: (id: string) => Promise<void>;
}

export const createGovernanceSlice: StateCreator<
  StoreState,
  [],
  [],
  GovernanceSlice
> = (set, get) => ({
  // Initial state
  proposals: [],
  currentProposal: null,
  userVotes: {},
  isLoading: false,
  error: null,

  // Actions
  fetchProposals: async (status) => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const url = status ? `/api/governance/proposals?status=${status}` : '/api/governance/proposals';
      const response = await fetch(url);
      if (!response.ok) throw new Error('Failed to fetch proposals');
      
      const proposals = await response.json();
      set((state) => {
        state.proposals = proposals;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  fetchProposal: async (id) => {
    set((state) => {
      state.isLoading = true;
      state.error = null;
    });

    try {
      const response = await fetch(`/api/governance/proposals/${id}`);
      if (!response.ok) throw new Error('Failed to fetch proposal');
      
      const proposal = await response.json();
      set((state) => {
        state.currentProposal = proposal;
        state.isLoading = false;
      });
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
        state.isLoading = false;
      });
    }
  },

  createProposal: async (proposal) => {
    try {
      const response = await fetch('/api/governance/proposals', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(proposal),
      });
      
      if (!response.ok) throw new Error('Failed to create proposal');
      await get().fetchProposals();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  updateProposal: async (id, updates) => {
    try {
      const response = await fetch(`/api/governance/proposals/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(updates),
      });
      
      if (!response.ok) throw new Error('Failed to update proposal');
      await get().fetchProposals();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  submitVote: async (proposalId, choice, reason) => {
    try {
      const response = await fetch(`/api/governance/proposals/${proposalId}/vote`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ choice, reason }),
      });
      
      if (!response.ok) throw new Error('Failed to submit vote');
      
      const vote = await response.json();
      set((state) => {
        state.userVotes[proposalId] = vote;
      });
      
      await get().fetchProposal(proposalId);
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },

  executeProposal: async (id) => {
    try {
      const response = await fetch(`/api/governance/proposals/${id}/execute`, {
        method: 'POST',
      });
      
      if (!response.ok) throw new Error('Failed to execute proposal');
      await get().fetchProposals();
    } catch (error) {
      set((state) => {
        state.error = error instanceof Error ? error.message : 'Unknown error';
      });
    }
  },
});
```

`dahao_0/src/types/index.ts`:

```ts
// Core DAHAO types

export interface DAHAOEntry {
  id: string;
  timestamp: string;
  title: string;
  description: string;
  participants: string[];
  tags: string[];
  relatedEntries?: string[];
  customData?: Record<string, any>;
}

export interface DAHAOFile {
  version: string;
  metadata: {
    created: string;
    lastModified: string;
    author: string;
  };
  entries: DAHAOEntry[];
}

export interface GitCommit {
  hash: string;
  author: string;
  date: string;
  message: string;
}

export interface GitDiff {
  file: string;
  additions: number;
  deletions: number;
  patch: string;
}

export interface ValidationResult {
  valid: boolean;
  errors?: ValidationError[];
}

export interface ValidationError {
  path: string;
  message: string;
  code: string;
}
```

`dahao_0/tailwind.config.ts`:

```ts
import type { Config } from 'tailwindcss'

const config: Config = {
  content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
    extend: {
      colors: {
        background: 'hsl(var(--background))',
        foreground: 'hsl(var(--foreground))',
        card: {
          DEFAULT: 'hsl(var(--card))',
          foreground: 'hsl(var(--card-foreground))',
        },
        popover: {
          DEFAULT: 'hsl(var(--popover))',
          foreground: 'hsl(var(--popover-foreground))',
        },
        primary: {
          DEFAULT: 'hsl(var(--primary))',
          foreground: 'hsl(var(--primary-foreground))',
        },
        secondary: {
          DEFAULT: 'hsl(var(--secondary))',
          foreground: 'hsl(var(--secondary-foreground))',
        },
        muted: {
          DEFAULT: 'hsl(var(--muted))',
          foreground: 'hsl(var(--muted-foreground))',
        },
        accent: {
          DEFAULT: 'hsl(var(--accent))',
          foreground: 'hsl(var(--accent-foreground))',
        },
        destructive: {
          DEFAULT: 'hsl(var(--destructive))',
          foreground: 'hsl(var(--destructive-foreground))',
        },
        border: 'hsl(var(--border))',
        input: 'hsl(var(--input))',
        ring: 'hsl(var(--ring))',
      },
      borderRadius: {
        lg: 'var(--radius)',
        md: 'calc(var(--radius) - 2px)',
        sm: 'calc(var(--radius) - 4px)',
      },
    },
  },
  plugins: [require('tailwindcss-animate')],
}
export default config
```

`dahao_0/tsconfig.json`:

```json
{
  "compilerOptions": {
    "target": "es5",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx"],
  "exclude": ["node_modules"]
}
```

`dahao_0/whatweardoing.md`:

```md
DAHAO Git-Based System: Complete Architecture Design
üéØ System Overview
What We're Building
A completely decentralized organizational governance system where:

Everything is stored in Git repositories (no traditional database)
All data is YAML files in structured directories
Organizations are Git repositories that can fork and inherit from each other
Users interact through a beautiful UI that hides Git complexity
All changes are tracked through Git's version control
Governance happens through Pull Requests and Git-based voting

Core Philosophy

Git as the Database: No PostgreSQL, MongoDB, or Firebase needed
YAML as the Data Format: Human-readable, diff-friendly, structured
Forks as Sub-Organizations: Natural inheritance and customization
Branches as Workspaces: Users and agents work in branches
Pull Requests as Proposals: Democratic decision-making through PRs
Commits as Audit Trail: Complete history of every change

üìä System Architecture Diagram
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         User Interface Layer                         ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê ‚îÇ
‚îÇ  ‚îÇ   Web App   ‚îÇ  ‚îÇ Mobile App  ‚îÇ  ‚îÇ   CLI Tool  ‚îÇ  ‚îÇ    API    ‚îÇ ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Git Operations Layer                            ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ  ‚îÇ   GitOperationsManager: Handles all Git interactions         ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   - Branch Management    - Commit Operations                 ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   - PR Creation          - Merge Handling                    ‚îÇ   ‚îÇ
‚îÇ  ‚îÇ   - Conflict Resolution  - Webhook Processing                ‚îÇ   ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                         Git Providers                                ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê             ‚îÇ
‚îÇ  ‚îÇ    GitHub    ‚îÇ  ‚îÇ    GitLab    ‚îÇ  ‚îÇ   Gitea      ‚îÇ             ‚îÇ
‚îÇ  ‚îÇ     API      ‚îÇ  ‚îÇ     API      ‚îÇ  ‚îÇ   (self-     ‚îÇ             ‚îÇ
‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ              ‚îÇ  ‚îÇ   hosted)    ‚îÇ             ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                    ‚îÇ
                                    ‚ñº
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                      Git Repository Structure                        ‚îÇ
‚îÇ                                                                      ‚îÇ
‚îÇ  dahao-org/                                                         ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ dahao-core/              (Main DAHAO - Template)              ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ dahao-climate/           (Fork of core - Climate focus)       ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ dahao-defi/              (Fork of core - DeFi focus)         ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ dahao-health/            (Fork of core - Health focus)       ‚îÇ
‚îÇ                                                                      ‚îÇ
‚îÇ  user-forks/                                                        ‚îÇ
‚îÇ  ‚îú‚îÄ‚îÄ alice/dahao-climate/     (Alice's fork of climate)           ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ bob/dahao-defi/          (Bob's fork of defi)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
üóÇÔ∏è Repository Structure
Core DAHAO Repository
dahao-core/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îú‚îÄ‚îÄ workflows/                    # GitHub Actions
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ validate-yaml.yml        # Validate all YAML on PR
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ check-inheritance.yml    # Verify sub-DAHAO compliance
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ run-governance.yml       # Auto-count votes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ sync-forks.yml          # Help forks stay updated
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ CODEOWNERS                   # Who can approve what
‚îÇ   ‚îî‚îÄ‚îÄ pull_request_template.md     # Proposal template
‚îÇ
‚îú‚îÄ‚îÄ constitution/
‚îÇ   ‚îú‚îÄ‚îÄ manifest.yaml                # DAHAO metadata
‚îÇ   ‚îú‚îÄ‚îÄ sections/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 00-preamble.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 01-what-is-dahao.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 02-core-values.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ 03-core-purpose.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ index.yaml                   # Section registry
‚îÇ
‚îú‚îÄ‚îÄ terms/
‚îÇ   ‚îú‚îÄ‚îÄ definitions/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ core/                    # Core terms (immutable in forks)
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ dahao.yaml
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hybrid-governance.yaml
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ extended/                # Can be extended in forks
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îú‚îÄ‚îÄ relationships.yaml           # Term relationships graph
‚îÇ   ‚îî‚îÄ‚îÄ registry.yaml               # Master term index
‚îÇ
‚îú‚îÄ‚îÄ governance/
‚îÇ   ‚îú‚îÄ‚îÄ rules.yaml                   # Voting rules, thresholds
‚îÇ   ‚îú‚îÄ‚îÄ roles.yaml                   # Permission system
‚îÇ   ‚îú‚îÄ‚îÄ members/                     # Member registry
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ alice.yaml
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ bob.yaml
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îÇ   ‚îî‚îÄ‚îÄ proposals/
‚îÇ       ‚îú‚îÄ‚îÄ templates/               # Proposal templates
‚îÇ       ‚îú‚îÄ‚îÄ active/                  # Current proposals
‚îÇ       ‚îî‚îÄ‚îÄ completed/               # Historical proposals
‚îÇ
‚îú‚îÄ‚îÄ tokens/                          # Economic system
‚îÇ   ‚îú‚îÄ‚îÄ economics.yaml              # Token rules
‚îÇ   ‚îú‚îÄ‚îÄ distribution.yaml           # How tokens are distributed
‚îÇ   ‚îî‚îÄ‚îÄ balances/                   # Token holdings
‚îÇ
‚îú‚îÄ‚îÄ agents/                          # AI Agent configurations
‚îÇ   ‚îú‚îÄ‚îÄ registry.yaml               # Registered agents
‚îÇ   ‚îú‚îÄ‚îÄ permissions.yaml            # What agents can do
‚îÇ   ‚îî‚îÄ‚îÄ workspaces/                 # Agent working directories
‚îÇ
‚îî‚îÄ‚îÄ .dahao/
    ‚îú‚îÄ‚îÄ version.yaml                # Framework version
    ‚îú‚îÄ‚îÄ inheritance.yaml            # What can be overridden
    ‚îî‚îÄ‚îÄ validation-rules.yaml       # Custom validation
Sub-DAHAO Repository (Fork)
dahao-climate/
‚îú‚îÄ‚îÄ parent.yaml                      # Points to dahao-core
‚îú‚îÄ‚îÄ constitution/
‚îÇ   ‚îú‚îÄ‚îÄ manifest.yaml               # Extends core manifest
‚îÇ   ‚îú‚îÄ‚îÄ sections/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _inherited/             # Symlinks to parent
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ climate-specific/       # New sections
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ 20-climate-mission.yaml
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ 21-carbon-credits.yaml
‚îÇ   ‚îî‚îÄ‚îÄ index.yaml                  # Combined index
‚îÇ
‚îú‚îÄ‚îÄ terms/
‚îÇ   ‚îî‚îÄ‚îÄ definitions/
‚îÇ       ‚îî‚îÄ‚îÄ climate/                # Climate-specific terms
‚îÇ           ‚îú‚îÄ‚îÄ carbon-credit.yaml
‚îÇ           ‚îú‚îÄ‚îÄ renewable-energy.yaml
‚îÇ           ‚îî‚îÄ‚îÄ ...
‚îÇ
‚îî‚îÄ‚îÄ governance/
    ‚îî‚îÄ‚îÄ rules.yaml                  # Overrides some core rules
üîÑ Data Flow Architecture
1. User Journey Flow
User Action ‚Üí UI Event ‚Üí Git Operation ‚Üí GitHub API ‚Üí Repository Change
     ‚Üì                                                        ‚Üì
   Response ‚Üê UI Update ‚Üê Webhook/Polling ‚Üê Git Event ‚Üê Commit/PR Created
2. Document Editing Flow
yaml# User clicks "Edit" on document
1. UI State:
   - documentId: "01-what-is-dahao"
   - mode: "editing"

2. Git Operations:
   - Create branch: "draft/alice/doc-01-edit-1709654321"
   - Checkout branch
   - Load current content from YAML

3. User edits in UI:
   - Real-time preview
   - Auto-save to branch every 30 seconds
   - Show diff from main

4. User clicks "Save & Submit":
   - Final commit to branch
   - Create Pull Request
   - Notify reviewers

5. Review Process:
   - Comments on PR
   - Suggested changes
   - Approval votes

6. Merge:
   - Auto-merge when threshold reached
   - Update main branch
   - Notify all users
3. Inheritance Flow
yaml# How sub-DAHAOs inherit from parent

1. Initial Fork:
   dahao-core ‚Üí dahao-climate (GitHub fork)

2. File Resolution:
   Request: constitution/sections/01-what-is-dahao.yaml
   
   Check Order:
   a. dahao-climate/constitution/sections/01-what-is-dahao.yaml (override?)
   b. dahao-climate/parent.yaml ‚Üí inherit from parent?
   c. dahao-core/constitution/sections/01-what-is-dahao.yaml (inherited)

3. Merge Strategy:
   if has_override:
     use override_content
   elif allows_inheritance:
     use parent_content
   else:
     error "Missing required section"

4. Sync Updates:
   - GitHub Action monitors parent
   - Creates PR when parent updates
   - Sub-DAHAO reviews and merges
üèóÔ∏è Core Components Design
1. GitOperationsManager
typescriptinterface GitOperationsManager {
  // Repository Management
  createDAHAO(name: string, type: 'core' | 'sub', parent?: string): Promise<Repository>
  forkDAHAO(sourceRepo: string, newName: string): Promise<Repository>
  deleteDAHAO(repoName: string): Promise<void>

  // Branch Operations
  createBranch(repo: string, branchName: string, fromBranch: string): Promise<Branch>
  deleteBranch(repo: string, branchName: string): Promise<void>
  listBranches(repo: string, filter?: BranchFilter): Promise<Branch[]>

  // File Operations
  readFile(repo: string, path: string, branch: string): Promise<YAMLContent>
  writeFile(repo: string, path: string, content: YAMLContent, branch: string): Promise<Commit>
  deleteFile(repo: string, path: string, branch: string): Promise<Commit>
  moveFile(repo: string, oldPath: string, newPath: string, branch: string): Promise<Commit>

  // Commit Operations
  commit(repo: string, branch: string, message: string, files: FileChange[]): Promise<Commit>
  getCommitHistory(repo: string, branch: string, path?: string): Promise<Commit[]>
  revertCommit(repo: string, commitSha: string): Promise<Commit>

  // Pull Request Operations
  createPR(repo: string, head: string, base: string, title: string, body: string): Promise<PullRequest>
  updatePR(repo: string, prNumber: number, updates: PRUpdate): Promise<PullRequest>
  mergePR(repo: string, prNumber: number, mergeMethod: MergeMethod): Promise<Merge>
  closePR(repo: string, prNumber: number): Promise<void>

  // Review Operations
  addReview(repo: string, prNumber: number, review: Review): Promise<void>
  requestReviewers(repo: string, prNumber: number, reviewers: string[]): Promise<void>

  // Conflict Resolution
  detectConflicts(repo: string, head: string, base: string): Promise<Conflict[]>
  resolveConflicts(repo: string, branch: string, resolution: ConflictResolution): Promise<Commit>
}
2. YAML Data Manager
typescriptinterface YAMLDataManager {
  // Schema Validation
  validateDocument(content: any, schemaType: SchemaType): ValidationResult
  validateTerm(content: any): ValidationResult
  validateGovernance(content: any): ValidationResult

  // Content Processing
  parseYAML(content: string): any
  stringifyYAML(data: any): string
  mergeYAML(base: any, override: any, strategy: MergeStrategy): any

  // Reference Resolution
  resolveTermReferences(content: string, termRegistry: TermRegistry): string
  findBrokenReferences(repo: string): BrokenReference[]
  updateReferences(oldId: string, newId: string, repo: string): FileChange[]

  // Indexing
  buildDocumentIndex(sections: Section[]): DocumentIndex
  buildTermIndex(terms: Term[]): TermIndex
  searchContent(query: string, index: Index): SearchResult[]
}
3. Inheritance Manager
typescriptinterface InheritanceManager {
  // Parent-Child Relationship
  setParent(childRepo: string, parentRepo: string, version: string): Promise<void>
  getParent(childRepo: string): Promise<ParentInfo>
  listChildren(parentRepo: string): Promise<ChildRepo[]>

  // Inheritance Rules
  getInheritanceRules(repo: string): InheritanceRules
  canOverride(repo: string, path: string): boolean
  mustInherit(repo: string, path: string): boolean

  // Content Resolution
  resolveContent(repo: string, path: string): Promise<ResolvedContent>
  getEffectiveContent(repo: string): Promise<EffectiveContent>
  getDiff(childRepo: string, parentRepo: string): Promise<DiffResult>

  // Sync Operations
  syncFromParent(childRepo: string, options: SyncOptions): Promise<SyncResult>
  proposeParentUpdate(childRepo: string, changes: Change[]): Promise<PullRequest>
  handleParentUpdate(childRepo: string, parentPR: PullRequest): Promise<void>
}
4. Governance Engine
typescriptinterface GovernanceEngine {
  // Proposal Management
  createProposal(proposal: Proposal): Promise<PullRequest>
  getProposalStatus(prNumber: number): Promise<ProposalStatus>
  executeProposal(prNumber: number): Promise<ExecutionResult>

  // Voting System
  castVote(prNumber: number, vote: Vote): Promise<void>
  tallyVotes(prNumber: number): Promise<VoteTally>
  checkQuorum(prNumber: number): Promise<QuorumStatus>

  // Permission System
  checkPermission(user: string, action: Action, resource: string): boolean
  grantRole(user: string, role: Role): Promise<void>
  revokeRole(user: string, role: Role): Promise<void>

  // Automation
  runGovernanceChecks(prNumber: number): Promise<CheckResult[]>
  autoMergeIfPassed(prNumber: number): Promise<boolean>
  notifyStakeholders(event: GovernanceEvent): Promise<void>
}
üñ•Ô∏è User Interface Architecture
1. UI Component Structure
src/
‚îú‚îÄ‚îÄ components/
‚îÇ   ‚îú‚îÄ‚îÄ constitution/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DocumentViewer.tsx      # View documents
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ DocumentEditor.tsx      # Edit documents
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ SectionBrowser.tsx     # Navigate sections
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ DiffViewer.tsx         # Show changes
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ terms/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TermBrowser.tsx        # Browse all terms
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TermEditor.tsx         # Edit terms
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ TermGraph.tsx          # Visualize relationships
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ TermSearch.tsx         # Search terms
‚îÇ   ‚îÇ
‚îÇ   ‚îú‚îÄ‚îÄ governance/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProposalList.tsx       # Active proposals
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ ProposalDetail.tsx     # Single proposal
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ VotingInterface.tsx    # Cast votes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GovernanceMetrics.tsx  # Stats/analytics
‚îÇ   ‚îÇ
‚îÇ   ‚îî‚îÄ‚îÄ git/
‚îÇ       ‚îú‚îÄ‚îÄ BranchSelector.tsx     # Switch branches
‚îÇ       ‚îú‚îÄ‚îÄ CommitHistory.tsx      # View history
‚îÇ       ‚îú‚îÄ‚îÄ PRCreator.tsx          # Create PRs
‚îÇ       ‚îî‚îÄ‚îÄ ConflictResolver.tsx   # Resolve conflicts
‚îÇ
‚îú‚îÄ‚îÄ hooks/
‚îÇ   ‚îú‚îÄ‚îÄ useGitRepo.ts              # Git operations
‚îÇ   ‚îú‚îÄ‚îÄ useYAMLData.ts             # Data operations
‚îÇ   ‚îú‚îÄ‚îÄ useGovernance.ts           # Governance logic
‚îÇ   ‚îî‚îÄ‚îÄ useInheritance.ts          # Inheritance logic
‚îÇ
‚îî‚îÄ‚îÄ lib/
    ‚îú‚îÄ‚îÄ git/                       # Git operation implementations
    ‚îú‚îÄ‚îÄ yaml/                      # YAML processing
    ‚îú‚îÄ‚îÄ validation/                # Schema validation
    ‚îî‚îÄ‚îÄ ai/                        # AI agent integration
2. State Management
typescriptinterface AppState {
  // Current Context
  currentRepo: Repository
  currentBranch: Branch
  currentUser: User
  
  // Document State
  documents: {
    sections: Section[]
    activeSectionId: string
    editMode: boolean
    unsavedChanges: boolean
  }
  
  // Term State
  terms: {
    registry: TermRegistry
    activeTerm: Term | null
    searchQuery: string
  }
  
  // Governance State
  governance: {
    activeProposals: Proposal[]
    userVotes: Vote[]
    permissions: Permission[]
  }
  
  // Git State
  git: {
    branches: Branch[]
    commits: Commit[]
    pullRequests: PullRequest[]
    conflicts: Conflict[]
  }
}
üîê Security Architecture
1. Authentication & Authorization
yaml# GitHub OAuth Flow
1. User clicks "Login with GitHub"
2. Redirect to GitHub OAuth
3. GitHub returns with token
4. Validate token and permissions
5. Create session with Git access

# Permission Levels
- Read: Can view repos and content
- Write: Can create branches and PRs
- Admin: Can merge PRs and modify governance
- Owner: Can delete repos and change permissions
2. Data Validation
yaml# Every YAML file is validated against schemas
Validation Pipeline:
1. Syntax Check: Valid YAML?
2. Schema Check: Matches expected structure?
3. Reference Check: All references exist?
4. Permission Check: User can make this change?
5. Business Logic: Follows DAHAO rules?
3. Audit Trail
yaml# Git provides complete audit trail
Every Change Tracked:
- Who: Git commit author
- What: Git diff
- When: Git commit timestamp
- Why: Git commit message + PR description
- Approved by: PR reviewers
üöÄ Deployment Architecture
1. Infrastructure Options
Option A: Serverless
yamlFrontend:
  - Vercel/Netlify for static site
  - CDN for global distribution

Backend:
  - AWS Lambda/Vercel Functions for API
  - GitHub API for Git operations
  - No database needed!

Benefits:
  - Scales automatically
  - Pay per use
  - No servers to manage
Option B: Self-Hosted
yamlFrontend:
  - Nginx serving static files
  - Docker container

Backend:
  - Node.js API server
  - Gitea for self-hosted Git
  - Docker compose setup

Benefits:
  - Full control
  - Can run offline
  - No vendor lock-in
2. CI/CD Pipeline
yaml# .github/workflows/deploy.yml
on:
  push:
    branches: [main]

jobs:
  validate:
    - Validate all YAML files
    - Run schema checks
    - Check term references
    
  test:
    - Unit tests for Git operations
    - Integration tests with GitHub API
    - UI component tests
    
  deploy:
    - Build UI with Next.js
    - Deploy to Vercel
    - Invalidate CDN cache
üîÑ Agent Integration
1. Agent Architecture
yamlAgent Types:
  1. Validator Agents:
     - Check document consistency
     - Validate term usage
     - Ensure inheritance rules

  2. Proposal Agents:
     - Suggest improvements
     - Create automated PRs
     - Analyze voting patterns

  3. Maintenance Agents:
     - Sync forks with parent
     - Clean up old branches
     - Archive completed proposals
2. Agent Workflow
typescriptclass AIAgent {
  async runAnalysis(repo: string) {
    // 1. Clone/pull latest
    await git.pull(repo, 'main');
    
    // 2. Create agent branch
    const branch = await git.createBranch(
      repo,
      `agent/${this.id}/analysis-${Date.now()}`
    );
    
    // 3. Analyze content
    const issues = await this.analyzeContent(repo);
    
    // 4. Generate fixes
    const fixes = await this.generateFixes(issues);
    
    // 5. Apply fixes to branch
    for (const fix of fixes) {
      await git.writeFile(repo, fix.path, fix.content, branch);
    }
    
    // 6. Create PR with analysis
    await git.createPR(
      repo,
      branch,
      'main',
      'AI Agent: Suggested improvements',
      this.formatAnalysis(issues, fixes)
    );
  }
}
üìà Scalability Considerations
1. Performance Optimization
yamlCaching Strategy:
  - Cache YAML parsing results
  - Cache inheritance resolution
  - Cache term index for search
  - Use Git's built-in efficiency

Lazy Loading:
  - Load sections on demand
  - Paginate large lists
  - Stream commit history
  - Progressive enhancement

CDN Usage:
  - Serve static content from CDN
  - Cache API responses
  - Use edge functions for common operations
2. Large-Scale Operations
yamlHandling Many Forks:
  - Use GitHub's fork network API
  - Batch sync operations
  - Webhook-based updates
  - Efficient diff algorithms

Managing Many Users:
  - OAuth token management
  - Rate limit handling
  - Queue system for operations
  - Sharding by organization
üéØ Key Benefits of This Architecture

True Decentralization: No central database, just Git
Complete History: Every change tracked forever
Natural Inheritance: Git forks provide hierarchy
Built-in Collaboration: PRs, reviews, comments
Offline Capable: Git works offline
Zero Infrastructure: Use GitHub's infrastructure
Standard Tools: Any Git client works
AI-Friendly: Agents are just Git users
Conflict Resolution: Git's proven algorithms
Infinite Scalability: Each DAHAO is independent
```

`dahao_0/whatwedone.md`:

```md
# What We've Done - DAHAO Implementation

## üéØ High-Level Overview

We've built the foundation of DAHAO - a decentralized organizational governance system that uses Git repositories as its database. No traditional database needed - everything is stored as YAML files in Git!

## üèóÔ∏è What's Been Built

### 1. **Core Architecture**
- **Git Operations Layer**: Complete Git operations manager that handles all repository interactions
- **YAML Processing**: Schema validation and YAML data management
- **Provider System**: Pluggable Git provider architecture (GitHub implemented, ready for GitLab/Gitea)

### 2. **Repository Template**
Created `dahao-template/` - a complete template repository that organizations can fork:
- Constitution documents and sections
- Term definitions and relationships
- Governance rules and voting system
- Token economics configuration
- Example proposals and workflows
- CI/CD workflows for validation

### 3. **Web Application**
Built a Next.js 14 application with:
- **Constitution Browser**: View and edit constitution documents
- **Document Editor**: Monaco-based editor with live preview
- **Diff Viewer**: See changes between versions
- **Section Navigation**: Browse through constitution sections

### 4. **Authentication System**
- **GitHub OAuth Integration**: Yes! Users can login through GitHub
- **Session Management**: JWT-based sessions
- **Protected Routes**: Middleware for auth protection
- **User Menu**: Profile dropdown with logout

### 5. **State Management**
- Zustand store for managing:
  - Git repository state
  - Document editing state
  - User authentication state
  - Governance/proposal state

### 6. **API Routes**
RESTful API endpoints for:
- Authentication (GitHub OAuth flow)
- Git operations (create/read/update files)
- Document management
- Governance proposals

## üöÄ How It Works

### User Login Flow:
1. User clicks "Sign in with GitHub" button
2. Redirected to GitHub for authorization
3. GitHub redirects back with auth code
4. We exchange code for access token
5. User can now perform Git operations with their GitHub account

### Creating a DAHAO:
1. User forks the `dahao-template` repository
2. Customizes constitution, terms, and governance rules
3. All changes tracked through Git commits
4. Other users can fork their DAHAO to create sub-organizations

### Governance Flow:
1. User creates a branch for their proposal
2. Makes changes to constitution/rules
3. Creates a Pull Request (proposal)
4. Members vote by approving/rejecting the PR
5. Auto-merge when threshold reached

## üîß Technical Stack

- **Frontend**: Next.js 14 (App Router), React, TypeScript, Tailwind CSS
- **State**: Zustand for state management
- **Editor**: Monaco Editor for YAML editing
- **Git**: Octokit for GitHub API
- **Auth**: GitHub OAuth + JWT sessions
- **Validation**: JSON Schema for YAML validation

## üìÅ Project Structure

```
dahao_0/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ app/              # Next.js pages and API routes
‚îÇ   ‚îú‚îÄ‚îÄ components/       # React components
‚îÇ   ‚îú‚îÄ‚îÄ lib/             # Core libraries (git, yaml, auth)
‚îÇ   ‚îú‚îÄ‚îÄ hooks/           # Custom React hooks
‚îÇ   ‚îú‚îÄ‚îÄ store/           # Zustand state management
‚îÇ   ‚îî‚îÄ‚îÄ types/           # TypeScript definitions
‚îú‚îÄ‚îÄ dahao-template/      # Template repository for DAHAOs
‚îî‚îÄ‚îÄ scripts/             # Utility scripts
```

## ‚úÖ What's Working

1. **GitHub Authentication**: Users can sign in with GitHub
2. **Repository Operations**: Create, read, update files in Git
3. **Constitution Viewer**: Browse and read constitution sections
4. **Document Editor**: Edit YAML documents with syntax highlighting
5. **Diff Viewer**: See what changed between versions
6. **State Management**: Reactive UI with Zustand
7. **Type Safety**: Full TypeScript implementation

## üöß Next Steps

1. **Proposal System**: Complete the PR-based governance
2. **Voting UI**: Interface for casting votes on proposals
3. **Fork Management**: UI for managing parent-child relationships
4. **Token System**: Implement token economics
5. **AI Agents**: Add agent integration for automation
6. **Deployment**: Deploy to Vercel/Netlify

## üéâ Summary

We've built a working foundation where users can:
- ‚úÖ Login with GitHub
- ‚úÖ Browse constitution documents
- ‚úÖ Edit YAML files through a nice UI
- ‚úÖ See version history and diffs
- ‚úÖ All data stored in Git (no database!)

The system is ready for testing and further development. Users interact through a modern web UI while all data operations happen through Git behind the scenes!
```